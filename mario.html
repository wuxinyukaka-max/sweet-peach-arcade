<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>CAKE_JUMP // ä¸€ä½“åŒ–ç³–æœç‰ˆ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background-color: var(--bg-main); overflow: hidden;
            /* å…è®¸ç¼©æ”¾ï¼Œä½†ä¸å½±å“å†…éƒ¨æ¯”ä¾‹ */
            touch-action: manipulation;
        }

        /* æ¸¸æˆå®¹å™¨ï¼šè®©ç”»å¸ƒå§‹ç»ˆä¿æŒæ¯”ä¾‹å¹¶å±…ä¸­ */
        #game-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        canvas {
            background: #EBE7E4;
            border: 6px solid white;
            border-radius: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            /* å…³é”®ï¼šè‡ªé€‚åº”å±å¹•ï¼Œä¿æŒæ¯”ä¾‹ */
            max-width: 95vw;
            max-height: 90vh;
            width: auto;
            height: auto;
            display: block;
            image-rendering: auto;
        }

        /* éšè—ä¹‹å‰çš„å¤–éƒ¨æ§åˆ¶å™¨å’ŒHUD */
        #hud, .controls { display: none !important; }

        /* ç»“ç®—å¼¹çª— - ä¾ç„¶ä½¿ç”¨ HTML ä¿è¯æ–‡å­—æ¸²æŸ“æ¸…æ™° */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(107, 94, 94, 0.3);
            display: none; align-items: center; justify-content: center;
            z-index: 2000; backdrop-filter: blur(10px);
        }
        .modal-content {
            background: white; width: 80%; max-width: 300px; padding: 30px;
            border-radius: 40px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="candy-bg"></div>
    <a href="index.html" class="back-home" style="position:absolute; top:20px; left:20px; z-index:110;">ğŸ  è¿”å›</a>

    <div id="game-container">
        <!-- å†…éƒ¨æ¯”ä¾‹è®¾å®šä¸º 400 x 750 (ç«–å±é•¿èƒ¶å›Š) -->
        <canvas id="gameCanvas" width="400" height="750"></canvas>
    </div>

    <div id="over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="result-title" style="color:var(--candy-pink); margin:0; font-size:1.5rem;">å“å‘€ï¼</h2>
            <p id="result-desc" style="color:#998888; margin:10px 0 20px; font-size: 0.9rem;"></p>
            <button class="cute-btn wide" onclick="resetGame()" style="width:100%; height:50px; border-radius:25px; font-size: 1rem;">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <script>
        // --- 1. éŸ³æ•ˆå¼•æ“ ---
        const CandyAudio = {
            ctx: null,
            init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); },
            play(type) {
                this.init(); const o = this.ctx.createOscillator(), g = this.ctx.createGain(); o.connect(g); g.connect(this.ctx.destination);
                const n = this.ctx.currentTime;
                if(type==='jump'){ o.type='sine'; o.frequency.setValueAtTime(150,n); o.frequency.exponentialRampToValueAtTime(650,n+0.2); g.gain.setValueAtTime(0.1,n); }
                if(type==='star'){ o.type='triangle'; o.frequency.setValueAtTime(600,n); o.frequency.exponentialRampToValueAtTime(1300,n+0.15); g.gain.setValueAtTime(0.1,n); }
                if(type==='break'){ o.type='square'; o.frequency.setValueAtTime(100,n); o.frequency.linearRampToValueAtTime(10,n+0.1); g.gain.setValueAtTime(0.05,n); }
                if(type==='dead'){ o.type='square'; o.frequency.setValueAtTime(250,n); o.frequency.linearRampToValueAtTime(50,n+0.4); g.gain.setValueAtTime(0.1,n); }
                o.start(); o.stop(n+0.5);
            }
        };

        // --- 2. æ ¸å¿ƒå˜é‡ ---
        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const modal = document.getElementById('over-modal');

        const BASE_WIDTH = 400, BASE_HEIGHT = 750;
        const GRAVITY = 0.8, JUMP_FORCE = -15, SPEED = 5, MAP_LENGTH = 12000;
        
        let player, platforms, cameraX, score, isGameOver, keys = { L:0, R:0, U:0, D:0 }, animationId = null;

        // UI æŒ‰é”®åŒºåŸŸå®šä¹‰ (ç›¸å¯¹äº 400x750 æ¯”ä¾‹)
        const uiButtons = {
            left:   { x: 30,  y: 640, w: 70, h: 70, icon: 'â—€', active: false },
            right:  { x: 120, y: 640, w: 70, h: 70, icon: 'â–¶', active: false },
            jump:   { x: 210, y: 640, w: 70, h: 70, icon: 'â–²', active: false },
            down:   { x: 300, y: 640, w: 70, h: 70, icon: 'â–¼', active: false }
        };

        function init() {
            if (animationId) cancelAnimationFrame(animationId);
            isGameOver = false; score = 0; cameraX = 0;
            Object.keys(keys).forEach(k => keys[k] = 0);
            player = { x: 50, y: 400, w: 32, h: 32, vx: 0, vy: 0, grounded: false };
            modal.style.display = 'none';
            generateMap();
            loop();
        }

        function generateMap() {
            platforms = [{ x: 0, y: 550, w: 600, h: 100, type: 'ground', active: true }];
            let cx = 650;
            while (cx < MAP_LENGTH) {
                let w = 80 + Math.random() * 120;
                let lastP = platforms[platforms.length - 1];
                let y = Math.max(150, Math.min(500, lastP.y + (Math.random() * 240 - 120)));
                let rand = Math.random();
                let type = rand > 0.85 ? 'brick' : (rand > 0.7 ? 'mystery' : 'cookie');
                platforms.push({ x: cx, y, w, h: 30, type, active: true });
                cx += w + 80 + Math.random() * 100;
            }
            platforms.push({ x: MAP_LENGTH, y: 450, w: 500, h: 200, type: 'end', active: true });
        }

        // --- 3. äº¤äº’ç³»ç»Ÿ (Canvas å†…åæ ‡è½¬æ¢) ---
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        function handleInput(e, isStart) {
            e.preventDefault();
            CandyAudio.init();
            const pos = getTouchPos(e);
            
            // æ£€æµ‹ç‚¹å‡»äº†å“ªä¸ª UI åŒºåŸŸ
            for (let b in uiButtons) {
                let btn = uiButtons[b];
                if (pos.x >= btn.x && pos.x <= btn.x + btn.w && pos.y >= btn.y && pos.y <= btn.y + btn.h) {
                    btn.active = isStart;
                    if (b === 'left') keys.L = isStart;
                    if (b === 'right') keys.R = isStart;
                    if (b === 'jump' && isStart && player.grounded) { 
                        player.vy = JUMP_FORCE; player.grounded = false; CandyAudio.play('jump'); 
                    }
                }
            }
        }

        canvas.addEventListener('pointerdown', (e) => handleInput(e, true));
        window.addEventListener('pointerup', () => {
            for (let b in uiButtons) uiButtons[b].active = false;
            keys.L = keys.R = false;
        });

        // --- 4. æ¸²æŸ“å¾ªç¯ ---
        function loop() {
            if (isGameOver) return;
            update();
            draw();
            animationId = requestAnimationFrame(loop);
        }

        function update() {
            if (keys.L) player.vx = -SPEED; else if (keys.R) player.vx = SPEED; else player.vx *= 0.85;
            player.vy += GRAVITY; player.x += player.vx; player.y += player.vy;
            player.grounded = false;

            platforms.forEach(p => {
                if (!p.active && p.type !== 'mystery_used') return;
                if (player.x + player.w > p.x && player.x < p.x + p.w && player.y + player.h > p.y && player.y < p.y + p.h) {
                    if (player.vy > 0 && player.y + player.h < p.y + p.h/2 + player.vy + 2) {
                        player.y = p.y - player.h; player.vy = 0; player.grounded = true;
                        if (p.type === 'end') win();
                    } else if (player.vy < 0 && player.y > p.y + p.h/2) {
                        player.y = p.y + p.h; player.vy = 1;
                        handleBlockHit(p);
                    }
                }
            });

            cameraX = Math.max(cameraX, player.x - 100);
            if (player.y > 650) endGame("å“å‘€ï¼Œæ‰ä¸‹å»äº†ï¼ğŸ©", "æ”¶é›†äº† " + score + " é¢—æ˜Ÿæ˜Ÿ");
            if (player.x < cameraX - 10) player.x = cameraX - 10;
        }

        function handleBlockHit(p) {
            if (p.type === 'brick') { p.active = false; CandyAudio.play('break'); }
            else if (p.type === 'mystery') { p.type = 'mystery_used'; score += 5; CandyAudio.play('star'); }
        }

        // --- 5. ç”»å¸ƒå†…éƒ¨ UI ç»˜åˆ¶ ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶åœºæ™¯
            ctx.save(); ctx.translate(-cameraX, 0);
            platforms.forEach(p => {
                if (!p.active && p.type !== 'mystery_used') return;
                if (p.type === 'end') {
                    ctx.fillStyle = "#D99FA9"; drawRoundedRect(ctx, p.x, p.y, p.w, p.h, 30);
                    ctx.font = "50px Arial"; ctx.fillText("ğŸ‚", p.x + p.w/2 - 25, p.y - 20);
                } else {
                    ctx.fillStyle = p.type === 'brick' ? "#E6D5B8" : (p.type === 'mystery' ? "#FFB6C1" : (p.type==='mystery_used'?"#D1C7C7": (p.type === 'ground' ? "#A89A90" : "#9BB7AD")));
                    drawRoundedRect(ctx, p.x, p.y, p.w, p.h, 10);
                    if(p.type === 'mystery') drawJellyStar(ctx, p.x + p.w/2, p.y + 16, 8, true);
                }
            });
            ctx.fillStyle = "#D99FA9"; drawRoundedRect(ctx, player.x, player.y, player.w, player.h, 10);
            ctx.restore();

            // --- æ ¸å¿ƒï¼šç»˜åˆ¶ Canvas å†…éƒ¨ UI ---
            
            // 1. é¡¶éƒ¨ç§¯åˆ† HUD
            ctx.fillStyle = "rgba(255,255,255,0.9)";
            drawRoundedRect(ctx, 110, 25, 180, 45, 22.5); // ç§¯åˆ†åº•åº§
            ctx.fillStyle = "#D99FA9";
            ctx.font = "bold 18px Quicksand, Arial";
            ctx.textAlign = "center";
            ctx.fillText(`â­ ${score}  ğŸš© ${Math.floor(player.x/10)}m`, 200, 54);

            // 2. åº•éƒ¨æ§åˆ¶æŒ‰é’®
            for (let b in uiButtons) {
                let btn = uiButtons[b];
                ctx.save();
                // æŒ‰é’®åº•åº§ï¼šç‚¹å‡»æ—¶å˜å®è‰²ï¼Œå¹³æ—¶åŠé€æ˜
                ctx.fillStyle = btn.active ? "rgba(217, 159, 169, 0.9)" : "rgba(155, 183, 173, 0.4)";
                ctx.strokeStyle = "rgba(255,255,255,0.8)";
                ctx.lineWidth = 4;
                drawRoundedRect(ctx, btn.x, btn.y, btn.w, btn.h, 18);
                ctx.stroke();

                // æŒ‰é’®å›¾æ ‡
                ctx.fillStyle = "white";
                ctx.font = "bold 30px Arial";
                ctx.textAlign = "center";
                ctx.fillText(btn.icon, btn.x + btn.w/2, btn.y + btn.h/2 + 10);
                ctx.restore();
            }
        }

        // --- å·¥å…·å‡½æ•° ---
        function drawJellyStar(ctx, x, y, r, isMini = false) {
            ctx.save(); ctx.translate(x, y); ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * r, -Math.sin((18 + i * 72) / 180 * Math.PI) * r);
                ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * (r/2.2), -Math.sin((54 + i * 72) / 180 * Math.PI) * (r/2.2));
            }
            ctx.closePath();
            let g = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
            g.addColorStop(0, '#F7DC6F'); g.addColorStop(1, '#D4AC0D');
            ctx.fillStyle = g; ctx.fill();
            if(!isMini){ ctx.strokeStyle = "white"; ctx.stroke(); }
            ctx.restore();
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); ctx.fill();
        }

        function win() { CandyAudio.play('star'); endGame("ç¾å‘³åˆ°è¾¾ï¼ğŸ‰", "ä½ æˆåŠŸæ‹¿åˆ°äº†ç»ˆæå¤§è›‹ç³•ï¼æ”¶é›†æ˜Ÿæ˜Ÿ: " + score); }
        function endGame(t, d) { isGameOver = true; CandyAudio.play('dead'); modal.style.display = 'flex'; document.getElementById('result-title').innerText = t; document.getElementById('result-desc').innerText = d; }
        function resetGame() { CandyAudio.init(); init(); }

        init();
    </script>
</body>
</html>