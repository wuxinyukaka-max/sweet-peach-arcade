<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JELLY_TETRIS // è«å…°è¿ªæœå†»æ–¹å—</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* --- 1. ç»å¯¹å±…ä¸­å¸ƒå±€ï¼šæ ¸å¿ƒä¿®æ­£ --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-main);
            /* ä½¿ç”¨ Flex ç¡®ä¿å†…å®¹åœ¨å±å¹•æ­£ä¸­å¿ƒ */
            display: flex;
            align-items: center; 
            justify-content: center;
            touch-action: none;
            -webkit-user-select: none;
        }

        /* èƒŒæ™¯æ³¢ç‚¹ä¿æŒåœ¨åº•å±‚ */
        .candy-bg { position: fixed; z-index: -1; }

        /* é¡¶éƒ¨å’Œè¿”å›æŒ‰é’®ï¼šè®¾ä¸ºç»å¯¹å®šä½ï¼Œä¸å‚ä¸ä¸­å¿ƒå¯¹é½çš„è®¡ç®— */
        .back-home {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }

        #hud {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 1000;
        }

        /* --- æ ¸å¿ƒï¼šæ¸¸æˆç»„åˆèƒ¶å›Š --- */
        .game-assembly {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            /* ç§»é™¤å¯èƒ½å¯¼è‡´åç§»çš„ margin */
            margin: 0; 
        }

        #canvas-wrap {
            /* å¼ºåˆ¶é‡ç½® style.css é‡Œçš„æ ·å¼ */
            width: auto !important;
            height: auto !important;
            display: block !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        canvas { 
            background: #EBE7E4; 
            border: 6px solid white;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.05);
            /* é’ˆå¯¹æ‰‹æœºç«–å±ä¼˜åŒ–çš„æ˜¾ç¤ºæ¯”ä¾‹ */
            max-height: 52vh; 
            max-width: 75vw;
            width: auto;
            height: auto;
            display: block;
        }

        /* æ“ä½œæŒ‰é’®ï¼šç´§ç´§è´´åœ¨ç”»å¸ƒä¸‹é¢ */
        .tight-controls {
            margin-top: 15px; /* ç”»å¸ƒä¸æŒ‰é’®çš„ç´§å‡‘é—´è· */
            display: flex;
            gap: 12px;
            padding: 0;
            pointer-events: auto;
        }

        /* æŒ‰é’®æ ·å¼ï¼šä¿æŒè«å…°è¿ªæ¸…æ–°æ„Ÿ */
        .cute-btn {
            width: 62px; 
            height: 62px; 
            border: 4px solid white;
            background: rgba(217, 159, 169, 0.8); 
            border-radius: 20px;
            font-size: 1.5rem; 
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 0px rgba(180, 140, 140, 0.2);
            backdrop-filter: blur(5px);
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .btn-mint {
            background: rgba(155, 183, 173, 0.8);
            box-shadow: 0 4px 0px rgba(130, 150, 140, 0.2);
        }

        .cute-btn:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0px rgba(0,0,0,0.1);
        }

        /* å¼¹çª—å®Œç¾å±…ä¸­ */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(107, 94, 94, 0.3);
            display: none; align-items: center; justify-content: center;
            z-index: 2000; backdrop-filter: blur(8px);
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 40px;
            text-align: center; box-shadow: 0 25px 60px rgba(0, 0, 0, 0.1);
            width: 80%; max-width: 300px;
            border: 1px solid rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div class="candy-bg"></div>
    <a href="index.html" class="back-home" id="back-link">ğŸ  è¿”å›</a>

    <div id="hud">
        <div class="score-box">ğŸ® ç”œç¾åˆ†: <span id="score">0</span></div>
    </div>

    <!-- æ¸¸æˆæ•´ä½“åŒ…ï¼šç›´æ¥å— body çš„ Flex å±…ä¸­æ§åˆ¶ -->
    <div class="game-assembly">
        <div id="canvas-wrap">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
        </div>

        <div class="tight-controls">
            <div class="cute-btn btn-mint" id="btn-left">â†</div>
            <div class="cute-btn btn-mint" id="btn-right">â†’</div>
            <div class="cute-btn" id="btn-rotate">â†»</div>
            <div class="cute-btn btn-mint" id="btn-drop">â†“</div>
        </div>
    </div>

    <!-- ç»“ç®—å¼¹çª— -->
    <div id="over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 style="color: var(--candy-pink); font-size: 1.6rem; margin-bottom: 8px;">å“å‘€ï¼å †æ»¡å•¦ ğŸ®</h2>
            <p style="color: #998888; font-size: 1rem; margin-bottom: 25px;">è·å¾—äº† <span id="final-score" style="color:var(--candy-pink); font-weight:bold;">0</span> ç§¯åˆ†</p>
            <button class="cute-btn wide" onclick="resetGame()" style="width: 100%; height: 55px; border-radius: 30px; font-size: 1.1rem;">å†æ¥ä¸€å±€ï¼</button>
        </div>
    </div>

    <script>
        // --- éŸ³æ•ˆå¼•æ“ (Web Audio API) ---
        const CandyAudio = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            playClick() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            },
            playCollect() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            },
            playGameOver() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.5);
            }
        };

        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score'), modal = document.getElementById('over-modal');

        const COLS = 10, ROWS = 20, BLOCK = 30;
        let board, score, isGameOver, lastTick, tickSpeed, curr;

        const COLORS = [null, '#D99FA9', '#A1B5D0', '#9BB7AD', '#E6D5B8', '#B4A7AF', '#C9A7AC', '#ADB8A6'];
        const SHAPES = [null, [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]];

        function init() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0; isGameOver = false; tickSpeed = 800; lastTick = performance.now();
            scoreEl.innerText = score; modal.style.display = 'none';
            newPiece(); requestAnimationFrame(loop);
        }

        function newPiece() {
            const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            curr = { s: SHAPES[id], color: id, x: Math.floor(COLS/2)-Math.floor(SHAPES[id][0].length/2), y: 0 };
            if (collide(curr.x, curr.y, curr.s)) {
                isGameOver = true; CandyAudio.playGameOver();
                document.getElementById('final-score').innerText = score;
                modal.style.display = 'flex';
            }
        }

        function collide(nx, ny, ns) {
            return ns.some((row, dy) => row.some((v, dx) => {
                if (v === 0) return false;
                let x = nx + dx; let y = ny + dy;
                return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x]);
            }));
        }

        const bind = (id, fn) => {
            const el = document.getElementById(id);
            el.addEventListener('pointerdown', (e) => {
                e.preventDefault(); if(isGameOver) return;
                CandyAudio.playClick(); fn(); draw();
            });
        };

        bind('btn-left', () => { if (!collide(curr.x - 1, curr.y, curr.s)) curr.x--; });
        bind('btn-right', () => { if (!collide(curr.x + 1, curr.y, curr.s)) curr.x++; });
        bind('btn-drop', () => { if (!collide(curr.x, curr.y + 1, curr.s)) curr.y++; });
        bind('btn-rotate', () => {
            let rs = curr.s[0].map((_, i) => curr.s.map(row => row[i]).reverse());
            if (!collide(curr.x, curr.y, rs)) curr.s = rs;
        });

        document.getElementById('back-link').onclick = () => CandyAudio.playClick();

        function loop(t) {
            if (isGameOver) return;
            requestAnimationFrame(loop);
            if (t - lastTick > tickSpeed) {
                if (!collide(curr.x, curr.y + 1, curr.s)) { curr.y++; } 
                else { freeze(); clearLines(); newPiece(); }
                lastTick = t;
            }
            draw();
        }

        function freeze() { curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) board[curr.y + dy][curr.x + dx] = curr.color; })); }

        function clearLines() {
            let lines = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(v => v !== 0)) {
                    board.splice(y, 1); board.unshift(Array(COLS).fill(0));
                    lines++; y--;
                }
            }
            if (lines > 0) {
                score += lines * 100; scoreEl.innerText = score;
                CandyAudio.playCollect();
                if (tickSpeed > 200) tickSpeed -= 25;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "rgba(107, 94, 94, 0.04)"; ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) { ctx.beginPath(); ctx.moveTo(x * BLOCK, 0); ctx.lineTo(x * BLOCK, canvas.height); ctx.stroke(); }
            for (let y = 0; y <= ROWS; y++) { ctx.beginPath(); ctx.moveTo(0, y * BLOCK); ctx.lineTo(canvas.width, y * BLOCK); ctx.stroke(); }
            board.forEach((row, y) => row.forEach((v, x) => { if (v) drawJellyBlock(x, y, COLORS[v]); }));
            if (curr.s) curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) drawJellyBlock(curr.x + dx, curr.y + dy, COLORS[curr.color]); }));
        }

        function drawJellyBlock(x, y, color) {
            const px = x * BLOCK, py = y * BLOCK, r = 8;
            ctx.fillStyle = color; ctx.beginPath();
            if (ctx.roundRect) ctx.roundRect(px+2, py+2, BLOCK-4, BLOCK-4, r);
            else ctx.rect(px+2, py+2, BLOCK-4, BLOCK-4);
            ctx.fill();
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)"; ctx.beginPath(); 
            ctx.ellipse(px+10, py+10, 5, 3, Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.35)"; ctx.lineWidth = 1.2; ctx.stroke();
        }

        function resetGame() { CandyAudio.playClick(); init(); }
        init();
    </script>
</body>
</html>