<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- 1. è§†å£æŒ‡ä»¤åŠ å›º -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JELLY_TETRIS // è«å…°è¿ªæœå†»æ–¹å—</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* --- æ ¸å¿ƒï¼šå½»åº•é”å®šå±å¹• --- */
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden; /* ç¦æ­¢æº¢å‡ºæ»šåŠ¨ */
            background-color: var(--bg-main);
            /* æœºåˆ¶1ï¼šç¦æ­¢æ‰€æœ‰é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼ˆç¼©æ”¾ã€å¹³ç§»ã€æ©¡çš®ç­‹å›å¼¹ï¼‰ */
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
            /* ä¿è¯ Flex å®¹å™¨å æ»¡å…¨å±å¹¶å±…ä¸­ */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* æœºåˆ¶2ï¼šå¯¹å¯ç‚¹å‡»å…ƒç´ è¿›ä¸€æ­¥åŠ å¼ºç¦æ­¢ç¼©æ”¾ */
        .cute-btn, canvas, .back-home, .modal-overlay {
            touch-action: none;
        }

        /* é¡¶éƒ¨/è¿”å›æŒ‰é’®ï¼šè„±ç¦»æ–‡æ¡£æµï¼Œä¸å¹²æ‰°ä¸­å¿ƒå¯¹é½ */
        .back-home { position: absolute; top: 20px; left: 20px; z-index: 1000; }
        #hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: center; pointer-events: none; z-index: 1000; }

        /* --- æ¸¸æˆç»„ä»¶ï¼šç´§å‡‘ç»„åˆ --- */
        .game-capsule {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0;
        }

        #canvas-wrap {
            height: auto !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        canvas { 
            background: #EBE7E4; 
            border: 6px solid white;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.05);
            /* é’ˆå¯¹ä¸åŒå±å¹•æ¯”ä¾‹çš„è‡ªé€‚åº”é™åˆ¶ */
            max-height: 52vh; 
            max-width: 75vw;
            width: auto; height: auto;
            display: block;
        }

        /* æ§åˆ¶å°ï¼šç´§è´´ç”»å¸ƒ */
        .tight-row {
            margin-top: 15px; /* è¿™é‡Œæ§åˆ¶é—´è· */
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }

        .cute-btn {
            width: 62px; height: 62px; 
            border: 4px solid white;
            background: rgba(217, 159, 169, 0.85); 
            border-radius: 20px;
            font-size: 1.5rem; color: white;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 0px rgba(180, 140, 140, 0.2);
            backdrop-filter: blur(5px);
            cursor: pointer;
        }
        
        .btn-mint { background: rgba(155, 183, 173, 0.85); box-shadow: 0 4px 0px rgba(130, 150, 140, 0.2); }
        .cute-btn:active { transform: translateY(2px); box-shadow: 0 1px 0px rgba(0,0,0,0.1); }

        /* ç»“ç®—å¼¹çª— */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(107, 94, 94, 0.3);
            display: none; align-items: center; justify-content: center;
            z-index: 2000; backdrop-filter: blur(8px);
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 40px;
            text-align: center; box-shadow: 0 25px 60px rgba(0, 0, 0, 0.15);
            width: 80%; max-width: 280px;
        }
    </style>
</head>
<body>
    <div class="candy-bg"></div>
    <a href="index.html" class="back-home" id="back-link">ğŸ  è¿”å›</a>

    <div id="hud">
        <div class="score-box">ğŸ® ç”œç¾åˆ†: <span id="score">0</span></div>
    </div>

    <!-- æœºåˆ¶3ï¼šä½¿ç”¨ game-capsule å®¹å™¨ç¡®ä¿ç”»é¢å’ŒæŒ‰é’®åœ¨å±å¹•ç»å¯¹ä¸­å¿ƒ -->
    <div class="game-capsule">
        <div id="canvas-wrap">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
        </div>

        <div class="tight-row">
            <div class="cute-btn btn-mint" id="btn-left">â†</div>
            <div class="cute-btn btn-mint" id="btn-right">â†’</div>
            <div class="cute-btn" id="btn-rotate">â†»</div>
            <div class="cute-btn btn-mint" id="btn-drop">â†“</div>
        </div>
    </div>

    <div id="over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 style="color: var(--candy-pink); font-size: 1.5rem; margin: 0 0 10px;">å“å‘€ï¼å †æ»¡å•¦ ğŸ®</h2>
            <p style="color: #998888; font-size: 1rem; margin-bottom: 25px;">è·å¾—äº† <span id="final-score" style="color:var(--candy-pink); font-weight:bold;">0</span> ç§¯åˆ†</p>
            <button class="cute-btn wide" onclick="resetGame()" style="width: 100%; height: 55px; border-radius: 30px; font-size: 1rem;">å†æ¥ä¸€å±€ï¼</button>
        </div>
    </div>

    <script>
        // --- ç»ˆæé˜²å¾¡ï¼šJS é˜»æ­¢åŒå‡»ç¼©æ”¾ ---
        document.addEventListener('touchstart', function (event) {
            if (event.touches.length > 1) {
                event.preventDefault(); // é˜»æ­¢å¤šæŒ‡ç¼©æ”¾
            }
        }, { passive: false });

        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            let now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault(); // é˜»æ­¢ 300ms å†…çš„åŒå‡»
            }
            lastTouchEnd = now;
        }, false);

        // --- éŸ³æ•ˆå¼•æ“ ---
        const CandyAudio = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            playClick() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            },
            playCollect() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            },
            playGameOver() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.5);
            }
        };

        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score'), modal = document.getElementById('over-modal');

        const COLS = 10, ROWS = 20, BLOCK = 30;
        let board, score, isGameOver, lastTick, tickSpeed, curr;

        const COLORS = [null, '#D99FA9', '#A1B5D0', '#9BB7AD', '#E6D5B8', '#B4A7AF', '#C9A7AC', '#ADB8A6'];
        const SHAPES = [null, [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]];

        function init() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0; isGameOver = false; tickSpeed = 800; lastTick = performance.now();
            scoreEl.innerText = score; modal.style.display = 'none';
            newPiece(); requestAnimationFrame(loop);
        }

        function newPiece() {
            const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            curr = { s: SHAPES[id], color: id, x: Math.floor(COLS/2)-Math.floor(SHAPES[id][0].length/2), y: 0 };
            if (collide(curr.x, curr.y, curr.s)) {
                isGameOver = true; CandyAudio.playGameOver();
                document.getElementById('final-score').innerText = score;
                modal.style.display = 'flex';
            }
        }

        function collide(nx, ny, ns) {
            return ns.some((row, dy) => row.some((v, dx) => {
                if (v === 0) return false;
                let x = nx + dx; let y = ny + dy;
                return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x]);
            }));
        }

        const bind = (id, fn) => {
            const el = document.getElementById(id);
            el.addEventListener('pointerdown', (e) => {
                e.preventDefault(); if(isGameOver) return;
                CandyAudio.playClick(); fn(); draw();
            });
        };

        bind('btn-left', () => { if (!collide(curr.x - 1, curr.y, curr.s)) curr.x--; });
        bind('btn-right', () => { if (!collide(curr.x + 1, curr.y, curr.s)) curr.x++; });
        bind('btn-drop', () => { if (!collide(curr.x, curr.y + 1, curr.s)) curr.y++; });
        bind('btn-rotate', () => {
            let rs = curr.s[0].map((_, i) => curr.s.map(row => row[i]).reverse());
            if (!collide(curr.x, curr.y, rs)) curr.s = rs;
        });

        function loop(t) {
            if (isGameOver) return;
            requestAnimationFrame(loop);
            if (t - lastTick > tickSpeed) {
                if (!collide(curr.x, curr.y + 1, curr.s)) { curr.y++; } 
                else { freeze(); clearLines(); newPiece(); }
                lastTick = t;
            }
            draw();
        }

        function freeze() { curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) board[curr.y + dy][curr.x + dx] = curr.color; })); }

        function clearLines() {
            let lines = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(v => v !== 0)) {
                    board.splice(y, 1); board.unshift(Array(COLS).fill(0));
                    lines++; y--;
                }
            }
            if (lines > 0) {
                score += lines * 100; scoreEl.innerText = score;
                CandyAudio.playCollect();
                if (tickSpeed > 200) tickSpeed -= 25;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "rgba(107, 94, 94, 0.04)"; ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) { ctx.beginPath(); ctx.moveTo(x * BLOCK, 0); ctx.lineTo(x * BLOCK, canvas.height); ctx.stroke(); }
            for (let y = 0; y <= ROWS; y++) { ctx.beginPath(); ctx.moveTo(0, y * BLOCK); ctx.lineTo(canvas.width, y * BLOCK); ctx.stroke(); }
            board.forEach((row, y) => row.forEach((v, x) => { if (v) drawJellyBlock(x, y, COLORS[v]); }));
            if (curr.s) curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) drawJellyBlock(curr.x + dx, curr.y + dy, COLORS[curr.color]); }));
        }

        function drawJellyBlock(x, y, color) {
            const px = x * BLOCK, py = y * BLOCK, r = 8;
            ctx.fillStyle = color; ctx.beginPath();
            if (ctx.roundRect) ctx.roundRect(px+2, py+2, BLOCK-4, BLOCK-4, r);
            else ctx.rect(px+2, py+2, BLOCK-4, BLOCK-4);
            ctx.fill();
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)"; ctx.beginPath(); 
            ctx.ellipse(px+10, py+10, 5, 3, Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.35)"; ctx.lineWidth = 1.2; ctx.stroke();
        }

        function resetGame() { CandyAudio.playClick(); init(); }
        init();
    </script>
</body>
</html>