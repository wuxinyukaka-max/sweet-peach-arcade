<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…è®¸ç”¨æˆ·ç¼©æ”¾ï¼Œä»¥ä¾¿è¯¯æ“ä½œåèƒ½æ‰‹åŠ¨æ¢å¤ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>JELLY_TETRIS // è«å…°è¿ªæœå†»æ–¹å—</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* --- æ ¸å¿ƒå¸ƒå±€ï¼šä¼˜é›…å±…ä¸­ä¸”ç´§å‡‘ --- */
        
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: center; /* å…¨å±å‚ç›´æ°´å¹³åŒé‡å±…ä¸­ */
            background-color: var(--bg-main);
            overflow: hidden;
            /* å…³é”®ï¼šå…è®¸åŒæŒ‡ç¼©æ”¾å’Œæ»šåŠ¨ï¼Œä½†ç¦ç”¨åŒå‡»ç¼©æ”¾ï¼Œæ¶ˆé™¤300mså»¶è¿Ÿ */
            touch-action: manipulation; 
        }

        /* é¡¶éƒ¨çŠ¶æ€æ ï¼šè®¾ä¸ºç»å¯¹å®šä½ï¼Œä¸å ç”¨ä¸­å¿ƒå¯¹é½çš„ç©ºé—´ */
        #hud {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }
        .score-box {
            background: white; padding: 6px 20px;
            border-radius: 15px; border: 2px solid var(--candy-pink);
            color: var(--candy-pink); font-size: 0.9rem; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        .back-home { position: absolute; top: 15px; left: 15px; z-index: 110; }

        /* --- æ¸¸æˆèƒ¶å›Šï¼šå°†ç”»å¸ƒå’ŒæŒ‰é’®æ‰“åŒ…åœ¨ä¸€èµ· --- */
        .game-capsule {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            /* å¦‚æœåœ¨æŸäº›æ‰‹æœºä¸Šè¿˜æ˜¯å¤ªæŒ¤ï¼Œå¯ä»¥å¾®è°ƒè¿™é‡Œ */
            gap: 15px; 
        }

        #canvas-wrap {
            height: auto !important;
            display: flex !important;
            justify-content: center;
        }

        canvas { 
            background: #EBE7E4; 
            border: 6px solid white;
            border-radius: 28px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            /* æ‰‹æœºç«–å±è‡ªé€‚åº”é«˜åº¦ */
            max-height: 52vh; 
            max-width: 70vw;
            width: auto;
            height: auto;
            display: block;
        }

        /* æŒ‰é’®é¢æ¿ï¼šç´§è·Ÿå…¶ä¸‹ */
        .button-panel {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 5px;
            pointer-events: auto;
        }

        /* æŒ‰é’®ï¼šè«å…°è¿ªæ¸…æ–°è´¨æ„Ÿ */
        .cute-btn {
            width: 60px; 
            height: 60px; 
            border: 3px solid white;
            background: rgba(217, 159, 169, 0.8); 
            border-radius: 18px;
            font-size: 1.5rem; 
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 0px rgba(180, 140, 140, 0.2);
            backdrop-filter: blur(5px);
            cursor: pointer;
            /* ç¡®ä¿æŒ‰é’®ç‚¹å‡»ä¸è§¦å‘ç³»ç»Ÿç¼©æ”¾ */
            touch-action: manipulation;
        }
        
        .btn-mint {
            background: rgba(155, 183, 173, 0.8);
            box-shadow: 0 4px 0px rgba(130, 150, 140, 0.2);
        }

        .cute-btn:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0px rgba(0,0,0,0.1);
        }

        /* ç»“ç®—å¼¹çª—å±…ä¸­ */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(107, 94, 94, 0.3);
            display: none; align-items: center; justify-content: center;
            z-index: 2000; backdrop-filter: blur(8px);
        }
    </style>
</head>
<body>
    <div class="candy-bg"></div>
    <a href="index.html" class="back-home" id="back-link">ğŸ  è¿”å›</a>

    <div id="hud">
        <div class="score-box">ğŸ® ç”œç¾åˆ†: <span id="score">0</span></div>
    </div>

    <!-- æ•´ä¸ªç»„åˆåœ¨ body ä¸­å±…ä¸­ -->
    <div class="game-capsule">
        <div id="canvas-wrap">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
        </div>

        <div class="button-panel">
            <div class="cute-btn btn-mint" id="btn-left">â†</div>
            <div class="cute-btn btn-mint" id="btn-right">â†’</div>
            <div class="cute-btn" id="btn-rotate">â†»</div>
            <div class="cute-btn btn-mint" id="btn-drop">â†“</div>
        </div>
    </div>

    <div id="over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 style="color: var(--candy-pink); font-size: 1.5rem; margin-bottom: 5px;">å“å‘€ï¼å †æ»¡å•¦ ğŸ®</h2>
            <p style="color: #998888; font-size: 0.9rem; margin-bottom: 20px;">æœ€ç»ˆå¾—åˆ†: <span id="final-score" style="color:var(--candy-pink); font-weight:bold;">0</span></p>
            <button class="cute-btn wide" onclick="resetGame()" style="width: 100%; height: 50px; font-size: 1rem; border-radius: 25px;">å†æ¥ä¸€å±€ï¼</button>
        </div>
    </div>

    <script>
        // --- éŸ³æ•ˆå¼•æ“ ---
        const CandyAudio = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            playClick() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            },
            playCollect() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            },
            playGameOver() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.5);
            }
        };

        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score'), modal = document.getElementById('over-modal');

        const COLS = 10, ROWS = 20, BLOCK = 30;
        let board, score, isGameOver, lastTick, tickSpeed, curr;

        const COLORS = [null, '#D99FA9', '#A1B5D0', '#9BB7AD', '#E6D5B8', '#B4A7AF', '#C9A7AC', '#ADB8A6'];
        const SHAPES = [null, [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]];

        function init() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0; isGameOver = false; tickSpeed = 800; lastTick = performance.now();
            scoreEl.innerText = score; modal.style.display = 'none';
            newPiece(); requestAnimationFrame(loop);
        }

        function newPiece() {
            const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            curr = { s: SHAPES[id], color: id, x: Math.floor(COLS/2)-Math.floor(SHAPES[id][0].length/2), y: 0 };
            if (collide(curr.x, curr.y, curr.s)) {
                isGameOver = true; CandyAudio.playGameOver();
                document.getElementById('final-score').innerText = score;
                modal.style.display = 'flex';
            }
        }

        function collide(nx, ny, ns) {
            return ns.some((row, dy) => row.some((v, dx) => {
                if (v === 0) return false;
                let x = nx + dx; let y = ny + dy;
                return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x]);
            }));
        }

        const bind = (id, fn) => {
            const el = document.getElementById(id);
            // ä½¿ç”¨ pointerdownï¼Œç‚¹å‡»ååº”æœ€çµæ•ï¼Œä¸”ä¸å®¹æ˜“è§¦å‘æµè§ˆå™¨ç¼©æ”¾
            el.addEventListener('pointerdown', (e) => {
                e.preventDefault(); if(isGameOver) return;
                CandyAudio.playClick(); fn(); draw();
            });
        };

        bind('btn-left', () => { if (!collide(curr.x - 1, curr.y, curr.s)) curr.x--; });
        bind('btn-right', () => { if (!collide(curr.x + 1, curr.y, curr.s)) curr.x++; });
        bind('btn-drop', () => { if (!collide(curr.x, curr.y + 1, curr.s)) curr.y++; });
        bind('btn-rotate', () => {
            let rs = curr.s[0].map((_, i) => curr.s.map(row => row[i]).reverse());
            if (!collide(curr.x, curr.y, rs)) curr.s = rs;
        });

        function loop(t) {
            if (isGameOver) return;
            requestAnimationFrame(loop);
            if (t - lastTick > tickSpeed) {
                if (!collide(curr.x, curr.y + 1, curr.s)) { curr.y++; } 
                else { freeze(); clearLines(); newPiece(); }
                lastTick = t;
            }
            draw();
        }

        function freeze() { curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) board[curr.y + dy][curr.x + dx] = curr.color; })); }

        function clearLines() {
            let lines = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(v => v !== 0)) {
                    board.splice(y, 1); board.unshift(Array(COLS).fill(0));
                    lines++; y--;
                }
            }
            if (lines > 0) {
                score += lines * 100; scoreEl.innerText = score;
                CandyAudio.playCollect();
                if (tickSpeed > 200) tickSpeed -= 25;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // è«å…°è¿ªç½‘æ ¼
            ctx.strokeStyle = "rgba(107, 94, 94, 0.05)"; ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) { ctx.beginPath(); ctx.moveTo(x * BLOCK, 0); ctx.lineTo(x * BLOCK, canvas.height); ctx.stroke(); }
            for (let y = 0; y <= ROWS; y++) { ctx.beginPath(); ctx.moveTo(0, y * BLOCK); ctx.lineTo(canvas.width, y * BLOCK); ctx.stroke(); }
            board.forEach((row, y) => row.forEach((v, x) => { if (v) drawJellyBlock(x, y, COLORS[v]); }));
            if (curr.s) curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) drawJellyBlock(curr.x + dx, curr.y + dy, COLORS[curr.color]); }));
        }

        function drawJellyBlock(x, y, color) {
            const px = x * BLOCK, py = y * BLOCK, r = 8;
            ctx.fillStyle = color; ctx.beginPath();
            if (ctx.roundRect) ctx.roundRect(px+2, py+2, BLOCK-4, BLOCK-4, r);
            else ctx.rect(px+2, py+2, BLOCK-4, BLOCK-4);
            ctx.fill();
            ctx.fillStyle = "rgba(255, 255, 255, 0.2)"; ctx.beginPath(); 
            ctx.ellipse(px+10, py+10, 5, 3, Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; ctx.lineWidth = 1.2; ctx.stroke();
        }

        function resetGame() { CandyAudio.playClick(); init(); }
        init();
    </script>
</body>
</html>