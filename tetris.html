<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JELLY_TETRIS // è«å…°è¿ªæœå†»æ–¹å—</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* --- 1. æ ¸å¿ƒå±…ä¸­å¸ƒå±€ä¿®æ­£ --- */
        
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* å…³é”®ï¼šå…¨å±å‚ç›´å±…ä¸­ */
            background-color: var(--bg-main);
            overflow: hidden;
        }

        /* å¼ºåˆ¶è¦†ç›– style.css å¯èƒ½å­˜åœ¨çš„å¹²æ‰°æ ·å¼ */
        #canvas-wrap {
            height: auto !important;
            width: auto !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            margin: 0 !important;
            padding: 0 !important;
            background: transparent !important;
            position: relative;
        }

        /* æ¸¸æˆä¸»ä½“ç»„åˆï¼šCanvas + æŒ‰é’® */
        .game-main-bundle {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* ç”»å¸ƒå’ŒæŒ‰é’®ä¹‹é—´çš„é—´è· */
            width: 100%;
        }

        canvas { 
            background: #EBE7E4; 
            border: 6px solid white;
            border-radius: 30px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.05);
            /* é€‚é…æ‰‹æœºç«¯é«˜åº¦ï¼šç¡®ä¿æ•´ä½“åœ¨å±å¹•å†…å±…ä¸­ */
            max-height: 55vh; 
            max-width: 70vw;
            width: auto;
            height: auto;
            display: block;
        }

        /* æ“ä½œæŒ‰é’®åŒºï¼šç´§è´´ç”»å¸ƒä¸‹æ–¹ */
        .tight-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 12px;
            width: 100%;
            padding: 5px;
            pointer-events: auto;
        }

        /* æŒ‰é’®æ ·å¼å¾®è°ƒ */
        .cute-btn {
            width: 62px; 
            height: 62px; 
            border: 4px solid white;
            background: rgba(217, 159, 169, 0.75); 
            border-radius: 20px;
            font-size: 1.6rem; 
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 5px 0px rgba(180, 140, 140, 0.2);
            backdrop-filter: blur(5px);
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .btn-mint {
            background: rgba(155, 183, 173, 0.75);
            box-shadow: 0 5px 0px rgba(130, 150, 140, 0.2);
        }

        .cute-btn:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0px rgba(0,0,0,0.1);
        }

        /* å…¶ä»–UIå…ƒç´  */
        #hud {
            position: fixed;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }

        .back-home { position: absolute; top: 20px; left: 20px; z-index: 1000; font-weight: bold; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(107, 94, 94, 0.3);
            display: none; align-items: center; justify-content: center;
            z-index: 2000; backdrop-filter: blur(8px);
        }
    </style>
</head>
<body>
    <div class="candy-bg"></div>
    <a href="index.html" class="back-home" id="back-link">ğŸ  è¿”å›</a>

    <!-- é¡¶éƒ¨ç§¯åˆ† -->
    <div id="hud">
        <div class="score-box">ğŸ® ç”œç”œåˆ†: <span id="score">0</span></div>
    </div>

    <!-- æ¸¸æˆæ•´ä½“å®¹å™¨ï¼šåœ¨å±å¹•ä¸­å®Œç¾å±…ä¸­ -->
    <div id="canvas-wrap">
        <div class="game-main-bundle">
            <!-- ç”»å¸ƒåŒº -->
            <canvas id="gameCanvas" width="300" height="600"></canvas>

            <!-- ç´§è´´ä¸‹æ–¹çš„æ“ä½œæŒ‰é’® -->
            <div class="tight-controls">
                <div class="cute-btn btn-mint" id="btn-left">â†</div>
                <div class="cute-btn btn-mint" id="btn-right">â†’</div>
                <div class="cute-btn" id="btn-rotate">â†»</div>
                <div class="cute-btn btn-mint" id="btn-drop">â†“</div>
            </div>
        </div>
    </div>

    <!-- ç»“ç®—å¼¹çª— -->
    <div id="over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 style="color: var(--candy-pink); margin-bottom: 5px;">å“å‘€ï¼å †æ»¡å•¦ ğŸ®</h2>
            <p style="color: #998888; font-size: 0.9rem; margin-bottom: 20px;">æœ€ç»ˆå¾—åˆ†: <span id="final-score" style="color:var(--candy-pink); font-weight:bold;">0</span></p>
            <button class="cute-btn wide" onclick="resetGame()" style="width: 100%; height: 50px; border-radius: 25px; font-size: 1rem;">å†æ¥ä¸€å±€ï¼</button>
        </div>
    </div>

    <script>
        // --- éŸ³æ•ˆå¼•æ“ ---
        const CandyAudio = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            playClick() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            },
            playCollect() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            },
            playGameOver() {
                this.init(); const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime); osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.5);
            }
        };

        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score'), modal = document.getElementById('over-modal');

        const COLS = 10, ROWS = 20, BLOCK = 30;
        let board, score, isGameOver, lastTick, tickSpeed, curr;

        const COLORS = [null, '#D99FA9', '#A1B5D0', '#9BB7AD', '#E6D5B8', '#B4A7AF', '#C9A7AC', '#ADB8A6'];
        const SHAPES = [null, [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]];

        function init() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0; isGameOver = false; tickSpeed = 800; lastTick = performance.now();
            scoreEl.innerText = score; modal.style.display = 'none';
            newPiece(); requestAnimationFrame(loop);
        }

        function newPiece() {
            const id = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            curr = { s: SHAPES[id], color: id, x: Math.floor(COLS/2)-Math.floor(SHAPES[id][0].length/2), y: 0 };
            if (collide(curr.x, curr.y, curr.s)) {
                isGameOver = true; CandyAudio.playGameOver();
                document.getElementById('final-score').innerText = score;
                modal.style.display = 'flex';
            }
        }

        function collide(nx, ny, ns) {
            return ns.some((row, dy) => row.some((v, dx) => {
                if (v === 0) return false;
                let x = nx + dx; let y = ny + dy;
                return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x]);
            }));
        }

        const bind = (id, fn) => {
            const el = document.getElementById(id);
            const handleAction = (e) => {
                e.preventDefault(); if(isGameOver) return;
                CandyAudio.playClick(); fn(); draw();
            };
            el.addEventListener('pointerdown', handleAction);
        };

        bind('btn-left', () => { if (!collide(curr.x - 1, curr.y, curr.s)) curr.x--; });
        bind('btn-right', () => { if (!collide(curr.x + 1, curr.y, curr.s)) curr.x++; });
        bind('btn-drop', () => { if (!collide(curr.x, curr.y + 1, curr.s)) curr.y++; });
        bind('btn-rotate', () => {
            let rs = curr.s[0].map((_, i) => curr.s.map(row => row[i]).reverse());
            if (!collide(curr.x, curr.y, rs)) curr.s = rs;
        });

        document.getElementById('back-link').onclick = () => CandyAudio.playClick();

        function loop(t) {
            if (isGameOver) return;
            requestAnimationFrame(loop);
            if (t - lastTick > tickSpeed) {
                if (!collide(curr.x, curr.y + 1, curr.s)) { curr.y++; } 
                else { freeze(); clearLines(); newPiece(); }
                lastTick = t;
            }
            draw();
        }

        function freeze() { curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) board[curr.y + dy][curr.x + dx] = curr.color; })); }

        function clearLines() {
            let lines = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(v => v !== 0)) {
                    board.splice(y, 1); board.unshift(Array(COLS).fill(0));
                    lines++; y--;
                }
            }
            if (lines > 0) {
                score += lines * 100; scoreEl.innerText = score;
                CandyAudio.playCollect();
                if (tickSpeed > 200) tickSpeed -= 20;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "rgba(107, 94, 94, 0.05)"; ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) { ctx.beginPath(); ctx.moveTo(x * BLOCK, 0); ctx.lineTo(x * BLOCK, canvas.height); ctx.stroke(); }
            for (let y = 0; y <= ROWS; y++) { ctx.beginPath(); ctx.moveTo(0, y * BLOCK); ctx.lineTo(canvas.width, y * BLOCK); ctx.stroke(); }
            
            board.forEach((row, y) => row.forEach((v, x) => { if (v) drawJellyBlock(x, y, COLORS[v]); }));
            if (curr.s) curr.s.forEach((row, dy) => row.forEach((v, dx) => { if (v) drawJellyBlock(curr.x + dx, curr.y + dy, COLORS[curr.color]); }));
        }

        function drawJellyBlock(x, y, color) {
            const px = x * BLOCK, py = y * BLOCK, r = 8;
            ctx.fillStyle = color; ctx.beginPath();
            if (ctx.roundRect) ctx.roundRect(px+2, py+2, BLOCK-4, BLOCK-4, r);
            else ctx.rect(px+2, py+2, BLOCK-4, BLOCK-4);
            ctx.fill();
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)"; ctx.beginPath(); 
            ctx.ellipse(px+10, py+10, 5, 3, Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.4)"; ctx.lineWidth = 1.2; ctx.stroke();
        }

        function resetGame() { CandyAudio.playClick(); init(); }
        init();
    </script>
</body>
</html>