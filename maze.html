<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>SWEET_MAZE // è¿·é›¾æŒ‘æˆ˜ç‰ˆ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background-color: var(--bg-main); overflow: hidden;
            touch-action: none;
        }
        #game-container {
            position: relative;
            display: flex; align-items: center; justify-content: center;
            width: 100%; height: 100%;
        }
        canvas {
            background: #F4F1F0;
            border: none !important;
            border-radius: 40px;
            box-shadow: none !important;
            max-width: 95vw;
            max-height: 92vh;
            width: auto; height: auto;
            display: block;
        }
        #hud, .controls, .button-panel { display: none !important; }
        .back-home { position: absolute; top: 20px; left: 20px; z-index: 1000; font-weight: bold; }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(107, 94, 94, 0.3);
            display: none; align-items: center; justify-content: center;
            z-index: 2000; backdrop-filter: blur(10px);
        }
        .modal-content {
            background: white; width: 80%; max-width: 300px; padding: 35px;
            border-radius: 40px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="candy-bg"></div>
    <a href="index.html" class="back-home" id="back-link">ğŸ  è¿”å›</a>

    <div id="game-container">
        <canvas id="gameCanvas" width="400" height="800"></canvas>
    </div>

    <div id="over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title" style="color: var(--candy-pink); margin: 0; font-size: 1.6rem;">æ—¶é—´è€—å°½ ğŸ©</h2>
            <p id="modal-desc" style="color: #998888; font-size: 0.95rem; margin: 15px 0 25px;">è¢«å›°åœ¨è¿·é›¾é‡Œäº†...</p>
            <button class="cute-btn wide" onclick="handleReset()" style="width: 100%; height: 50px; border-radius: 25px; font-size: 1rem;">å†æ¥ä¸€æ¬¡ï¼</button>
        </div>
    </div>

    <script>
        // --- 1. ç³–æœéŸ³æ•ˆå¼•æ“ (è«å…°è¿ªQå¼¹ç‰ˆ - é€‚é…è¿·å®«) ---
        const CandyAudio = {
            ctx: null,
            init() { 
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                if (this.ctx.state === 'suspended') this.ctx.resume(); 
            },
            play(type) {
                this.init();
                const n = this.ctx.currentTime;

                // 1. é¢‘ç¹ç§»åŠ¨çš„æŒ‰é”®éŸ³ï¼šä¿æŒé™éŸ³ï¼Œé¿å…åµé—¹
                if (type === 'click') return; 

                // åˆ›å»ºæ ¸å¿ƒèŠ‚ç‚¹
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                const f = this.ctx.createBiquadFilter();

                // æ»¤æ³¢å™¨è®¾ç½®ï¼šåˆ‡æ‰åˆºè€³é«˜é¢‘ï¼Œå¢åŠ æŸ”å’Œåº¦
                f.type = 'lowpass';
                f.Q.value = 4; // é€‚åº¦çš„å…±é¸£æ„Ÿ

                o.connect(f);
                f.connect(g);
                g.connect(this.ctx.destination);

                if (type === 'ding') {
                    // --- æˆåŠŸè„±å‡ºï¼šåƒæ‰“å¼€é¦™æ§Ÿä¸€æ ·çš„â€œå•¾å•ªï¼â€ ---
                    o.type = 'sine';
                    f.frequency.setValueAtTime(2000, n);
                    o.frequency.setValueAtTime(500, n);
                    o.frequency.exponentialRampToValueAtTime(1600, n + 0.15);
                    
                    g.gain.setValueAtTime(0, n);
                    g.gain.linearRampToValueAtTime(0.2, n + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.01, n + 0.3);
                    
                    o.start(n);
                    o.stop(n + 0.3);
                } 
                else if (type === 'bark') {
                    // --- è¢«ç‹—å’¬ï¼šæ²‰é—·çš„ç‰©ç†ç¢°æ’æ„Ÿâ€œå™—å””ï¼â€ ---
                    o.type = 'triangle';
                    f.frequency.setValueAtTime(400, n); // æä½æ»¤æ³¢ï¼Œå£°éŸ³å¾ˆåšå®
                    
                    o.frequency.setValueAtTime(150, n);
                    o.frequency.linearRampToValueAtTime(250, n + 0.05);
                    o.frequency.linearRampToValueAtTime(100, n + 0.15);
                    
                    g.gain.setValueAtTime(0, n);
                    g.gain.linearRampToValueAtTime(0.2, n + 0.01);
                    g.gain.linearRampToValueAtTime(0, n + 0.15);
                    
                    o.start(n);
                    o.stop(n + 0.15);
                }
                else if (type === 'sad') {
                    // --- å¤±è´¥ï¼šè½¯ç³¯çš„ä¸‹æ²‰éŸ³â€œå‘œ~â€ ---
                    o.type = 'triangle';
                    f.frequency.setValueAtTime(350, n);
                    
                    o.frequency.setValueAtTime(220, n);
                    o.frequency.exponentialRampToValueAtTime(60, n + 0.5);
                    
                    g.gain.setValueAtTime(0.2, n);
                    g.gain.linearRampToValueAtTime(0, n + 0.5);
                    
                    o.start(n);
                    o.stop(n + 0.5);
                }
            }
        };

        const iconAssets = { left: new Image(), right: new Image(), up: new Image(), down: new Image() };
        iconAssets.left.src = 'icons/left.svg'; iconAssets.right.src = 'icons/right.svg';
        iconAssets.up.src = 'icons/up.svg'; iconAssets.down.src = 'icons/down.svg';

        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const modal = document.getElementById('over-modal');

        const CELL = 16, COLS = 23, ROWS = 34; 
        const GAME_X_OFFSET = (400 - COLS * CELL) / 2; 
        const GAME_Y_OFFSET = 85; 

        let grid, player, exit, timeLeft, isGameOver, timerInterval, dogs, rippleDecors;
        let activeMoveDir = null, lastMoveTimestamp = 0, messageTip = { text: "", timer: 0 };
        let animationId = null;
        const MOVE_INTERVAL = 95;

        const uiBtns = {
            L: { x: 100,  y: 710, w: 60, h: 50, img: iconAssets.left,  move: {x: -1, y: 0}, color: '#9BB7AD' },
            R: { x: 245, y: 710, w: 60, h: 50, img: iconAssets.right, move: {x: 1, y: 0},  color: '#9BB7AD' },
            U: { x: 170, y: 650, w: 60, h: 50, img: iconAssets.up,    move: {x: 0, y: -1}, color: '#D99FA9' },
            D: { x: 170, y: 710, w: 60, h: 50, img: iconAssets.down,  move: {x: 0, y: 1},  color: '#9BB7AD' }
        };

        const joystick = {
            baseX: 200, baseY: 700, baseR: 50,
            stickX: 200, stickY: 700, stickR: 25,
            active: false, maxLen: 40
        };

        // --- 1. æ–°å¢ï¼šæ§åˆ¶æ¨¡å¼ç®¡ç† ---
let controlMode = 'button'; // é»˜è®¤ä¸ºæŒ‰é’®æ¨¡å¼

const toggleUI = {
    x: 25,          // è·ç¦»å·¦è¾¹ 35px
    y: 650,         // æ”¾åœ¨æ¸¸æˆåŒºå’Œæ§åˆ¶æŒ‰é’®ä¹‹é—´
    w: 60,          // å¼€å…³æ€»å®½
    h: 30,          // å¼€å…³æ€»é«˜
    knobR: 12       // åœ†å½¢æ»‘å—åŠå¾„
};

        function init() {
            if (animationId) cancelAnimationFrame(animationId);
            if (timerInterval) clearInterval(timerInterval);

            grid = []; player = { x: 1, y: 1 }; exit = { x: 1, y: 1 }; 
            timeLeft = 60; isGameOver = false; activeMoveDir = null; dogs = [];
            messageTip = { text: "", timer: 0 };
            modal.style.display = 'none';
            
            rippleDecors = [];
            for(let i = 0; i < 12; i++) {
                rippleDecors.push({
                    x: Math.random() * 400, y: GAME_Y_OFFSET + Math.random() * (ROWS * CELL),
                    count: 2 + Math.floor(Math.random() * 2), baseRadius: 15 + Math.random() * 20
                });
            }

            genMaze();
            startTimer();
            loop(performance.now());
        }

        function genMaze() {
            grid = Array(ROWS).fill().map(() => Array(COLS).fill(1));
            const walk = (x, y) => {
                grid[y][x] = 0;
                // éš¾åº¦æå‡ï¼šéšæœºæ–¹å‘é€‰æ‹©æ›´ä¸å‡è¡¡ï¼Œäº§ç”Ÿæ›´å¤šé•¿æ­»è·¯
                const d = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
                for (let [dx, dy] of d) {
                    let nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < COLS - 1 && ny > 0 && ny < ROWS - 1 && grid[ny][nx] === 1) {
                        grid[y + dy / 2][x + dx / 2] = 0; walk(nx, ny);
                    }
                }
            };
            walk(1, 1);

            // --- æ ¸å¿ƒï¼šå¢åŠ è¿·å®«è¿·æƒ‘æ€§é€»è¾‘ ---
            // 1. éšæœºç§»é™¤15-20å µå¢™ï¼Œåˆ¶é€ å›è·¯(Loop)ï¼Œè®©ç©å®¶åœ¨é‡Œé¢è½¬åœˆ
            for(let i=0; i<20; i++){
                let rx = 1 + Math.floor(Math.random()*(COLS-2));
                let ry = 1 + Math.floor(Math.random()*(ROWS-2));
                if(grid[ry][rx] === 1) grid[ry][rx] = 0;
            }

            // 2. å¯»æ‰¾çœŸæ­£çš„å‡ºå£
            let potentialExits = [];
            for (let y = 1; y < ROWS - 1; y++) {
                for (let x = 1; x < COLS - 1; x++) {
                    if (grid[y][x] === 0) {
                        let dist = Math.abs(x - 1) + Math.abs(y - 1);
                        if (dist > (COLS + ROWS) / 1.4) potentialExits.push({x, y});
                    }
                }
            }
            exit = potentialExits.length > 0 ? potentialExits[Math.floor(Math.random() * potentialExits.length)] : { x: COLS-2, y: ROWS-2 };

            // 3. åœ¨æ­»èƒ¡åŒæˆ–äº¤å‰å£æ”¾æ›´å¤šçš„ç‹—
            for(let i=0; i<15; i++) {
                let rx = Math.floor(Math.random()*COLS), ry = Math.floor(Math.random()*ROWS);
                if(grid[ry][rx] === 0 && Math.abs(rx-player.x)>3 && (rx!==exit.x||ry!==exit.y)) dogs.push({x: rx, y: ry});
            }
        }

        function startTimer() {
            timerInterval = setInterval(() => { if (!isGameOver) { timeLeft--; if (timeLeft <= 0) endGame(false); } }, 1000);
        }

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
            const t = e.touches ? e.touches[0] : e;
            return { x: (t.clientX - rect.left) * scaleX, y: (t.clientY - rect.top) * scaleY };
        }

        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault(); CandyAudio.init();
            if (isGameOver) return;
            const pos = getTouchPos(e);

            // --- A. æ£€æµ‹æ¨¡å¼å¼€å…³ç‚¹å‡» ---
            if (pos.x > toggleUI.x && pos.x < toggleUI.x + toggleUI.w &&
                pos.y > toggleUI.y && pos.y < toggleUI.y + toggleUI.h) {
                controlMode = (controlMode === 'button' ? 'joystick' : 'button');
                // åˆ‡æ¢æ¨¡å¼æ—¶åœæ­¢æ‰€æœ‰ç§»åŠ¨ï¼Œé˜²æ­¢è¯¯èµ°
                activeMoveDir = null;
                for (let k in uiBtns) uiBtns[k].active = false;
                CandyAudio.play('click');
                draw();
                return; 
            }

            // --- B. åˆ†æ¨¡å¼å¤„ç†æ“ä½œ ---
            if (controlMode === 'button') {
                // åªæœ‰æŒ‰é’®æ¨¡å¼ä¸‹å“åº” L/R/U/D ç‚¹å‡»
                for (let k in uiBtns) {
                    let btn = uiBtns[k];
                    if (pos.x > btn.x && pos.x < btn.x + btn.w && pos.y > btn.y && pos.y < btn.y + btn.h) {
                        btn.active = true;
                        activeMoveDir = btn.move; // è§¦å‘è¿ç»­ç§»åŠ¨é€»è¾‘
                        CandyAudio.play('click');
                    }
                }
            } else {
                // åªæœ‰æ‘‡æ†æ¨¡å¼ä¸‹å“åº”æ‘‡æ†ç‚¹å‡»
                const d = Math.hypot(pos.x - joystick.baseX, pos.y - joystick.baseY);
                if (d < joystick.baseR + 20) {
                    joystick.active = true;
                    updateJoystick(pos.x, pos.y);
                    if (dist > 15) {
    if (Math.abs(dx) > Math.abs(dy)) activeMoveDir = {x: dx > 0 ? 1 : -1, y: 0};
    else activeMoveDir = {x: 0, y: dy > 0 ? 1 : -1};
} else {
    activeMoveDir = null; // å›åˆ°æ­»åŒºåœæ­¢ç§»åŠ¨
}
                }
            }
            draw();
        });

        window.addEventListener('pointermove', (e) => {
            if (isGameOver || !joystick.active) return;
            const pos = getTouchPos(e);
            updateJoystick(pos.x, pos.y);
            if (dist > 15) {
    if (Math.abs(dx) > Math.abs(dy)) activeMoveDir = {x: dx > 0 ? 1 : -1, y: 0};
    else activeMoveDir = {x: 0, y: dy > 0 ? 1 : -1};
} else {
    activeMoveDir = null; // å›åˆ°æ­»åŒºåœæ­¢ç§»åŠ¨
}
        });

        window.addEventListener('pointerup', () => { 
            for (let k in uiBtns) uiBtns[k].active = false; 
            activeMoveDir = null; 
            joystick.active = false;
            joystick.stickX = joystick.baseX; joystick.stickY = joystick.baseY;
        });

        function updateJoystick(tx, ty) {
            const dx = tx - joystick.baseX, dy = ty - joystick.baseY;
            const d = Math.hypot(dx, dy), a = Math.atan2(dy, dx);
            const m = Math.min(d, joystick.maxLen);
            joystick.stickX = joystick.baseX + Math.cos(a) * m;
            joystick.stickY = joystick.baseY + Math.sin(a) * m;

            if (d > 15) {
                if (Math.abs(dx) > Math.abs(dy)) activeMoveDir = {x: dx > 0 ? 1 : -1, y: 0};
                else activeMoveDir = {x: 0, y: dy > 0 ? 1 : -1};
            } else {
                activeMoveDir = null;
            }
        }

        function loop(t) {
            if (isGameOver) return;
            animationId = requestAnimationFrame(loop);
            if (activeMoveDir && t - lastMoveTimestamp > MOVE_INTERVAL) {
                let nx = player.x + activeMoveDir.x, ny = player.y + activeMoveDir.y;
                if (grid[ny] && grid[ny][nx] === 0) {
                    player.x = nx; player.y = ny;
                    checkDogs();
                    if (player.x === exit.x && player.y === exit.y) endGame(true);
                }
                lastMoveTimestamp = t;
            }
            draw();
        }

        function checkDogs() {
            dogs.forEach((dog, index) => {
                if (dog.x === player.x && dog.y === player.y) {
                    timeLeft = Math.max(0, timeLeft - 5);
                    messageTip = { text: "è¢«ç‹—å’¬å•¦ï¼æ—¶é—´-5s ğŸ•", timer: 100 };
                    dogs.splice(index, 1); CandyAudio.play('bark');
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const charX = GAME_X_OFFSET + player.x * CELL + CELL/2, charY = GAME_Y_OFFSET + player.y * CELL + CELL/2;

            // 1. åŸºç¡€ç‡•éº¦èƒŒæ™¯
            ctx.fillStyle = "#F4F1F0"; 
            ctx.fillRect(0, 0, 400, 800);

            // 2. æ¶Ÿæ¼ªåº•çº¹
            ctx.save();
            ctx.strokeStyle = "rgba(168, 154, 144, 0.15)";
            ctx.lineWidth = 1.2;
            rippleDecors.forEach(r => {
                for(let j = 1; j <= r.count; j++) {
                    ctx.beginPath(); ctx.arc(r.x, r.y, r.baseRadius * j, 0, Math.PI * 2);
                    ctx.setLineDash([5, 8]); ctx.stroke();
                }
            });
            ctx.restore();

            // --- æ ¸å¿ƒï¼šç»˜åˆ¶è¿·å®«æ´»åŠ¨åŒºåŸŸçš„â€œæ‰˜ç›˜â€ ---
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)"; // åŠé€æ˜ç™½
            drawRoundedRect(ctx, GAME_X_OFFSET - 5, GAME_Y_OFFSET - 5, (COLS * CELL) + 10, (ROWS * CELL) + 10, 15);
            
            // 3. å·§å…‹åŠ›å¢™ä½“
            ctx.fillStyle = "#8D7B6D";
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x] === 1) {
                        const px = GAME_X_OFFSET + x * CELL, py = GAME_Y_OFFSET + y * CELL;
                        ctx.beginPath(); if (ctx.roundRect) ctx.roundRect(px, py, CELL, CELL, 3); else ctx.rect(px, py, CELL, CELL); ctx.fill();
                        ctx.fillStyle = "#7A685B"; ctx.fillRect(px + 3, py + 3, CELL - 6, CELL - 6);
                        ctx.fillStyle = "#8D7B6D";
                        if (x < COLS - 1 && grid[y][x+1] === 1) { ctx.fillRect(px + CELL - 3, py, 6, CELL); ctx.fillStyle = "#7A685B"; ctx.fillRect(px + CELL - 3, py + 3, 6, CELL - 6); ctx.fillStyle = "#8D7B6D"; }
                        if (y < ROWS - 1 && grid[y+1][x] === 1) { ctx.fillRect(px, py + CELL - 3, CELL, 6); ctx.fillStyle = "#7A685B"; ctx.fillRect(px + 3, py + CELL - 3, CELL - 6, 6); ctx.fillStyle = "#8D7B6D"; }
                    }
                }
            }
            
            drawExitPortal(ctx, GAME_X_OFFSET + exit.x * CELL + CELL/2, GAME_Y_OFFSET + exit.y * CELL + CELL/2);
            ctx.font = "12px Arial";
            dogs.forEach(dog => ctx.fillText("ğŸ•", GAME_X_OFFSET + dog.x * CELL + CELL/2, GAME_Y_OFFSET + dog.y * CELL + CELL/2));

            // ç»˜åˆ¶èŒå…”ç©å®¶
            ctx.save(); ctx.translate(charX, charY);
            const br = Math.sin(Date.now() / 180) * 0.1; ctx.scale(1 + br, 1 - br);
            ctx.fillStyle = "#D99FA9"; drawRoundedRect(ctx,-6,-15,5,11,2.5); drawRoundedRect(ctx,1,-15,5,11,2.5);
            ctx.fillStyle = "#E9BFC7"; drawRoundedRect(ctx,-4.5,-13,2,7,1); drawRoundedRect(ctx,2.5,-13,2,7,1);
            ctx.fillStyle = "#ebd47d"; ctx.beginPath(); ctx.arc(0,-3,8.5,0,7); ctx.fill();
            ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth = 1; ctx.stroke();
            ctx.fillStyle = "#4A3B2F"; ctx.beginPath(); ctx.arc(-3.5,-4,1.8,0,7); ctx.arc(3.5,-4,1.8,0,7); ctx.fill();
            ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(-4,-4.5,0.6,0,7); ctx.arc(3,-4.5,0.6,0,7); ctx.fill();
            ctx.fillStyle = "rgba(255,133,161,0.4)"; ctx.beginPath(); ctx.arc(-5.5,-0.5,2.5,0,7); ctx.arc(5.5,-0.5,2.5,0,7); ctx.fill();
            ctx.fillStyle = "#FF85A1"; ctx.beginPath(); ctx.arc(0,-1.5,1.2,0,7); ctx.fill();
            ctx.restore();

            // --- éš¾åº¦æ ¸å¿ƒï¼šè¿·é›¾æ›´çª„æ›´æµ“ ---
            const viewRadius = Math.max(35, 75 - (60 - timeLeft)); // è§†é‡ç¼©å°åˆ°æçª„
            const gradient = ctx.createRadialGradient(charX, charY, viewRadius * 0.2, charX, charY, viewRadius);
            gradient.addColorStop(0, "rgba(235, 231, 228, 0)");
            gradient.addColorStop(0.7, "rgba(235, 231, 228, 0.4)");
            gradient.addColorStop(1, "rgba(235, 231, 228, 0.99)"); // å‡ ä¹å…¨é»‘
            ctx.fillStyle = gradient;
            ctx.fillRect(0, GAME_Y_OFFSET - 10, 400, ROWS * CELL + 20);

            if (messageTip.timer > 0) {
                ctx.fillStyle = "#8a515b"; ctx.font = "bold 18px Quicksand, Arial"; ctx.textAlign = "center";
                ctx.fillText(messageTip.text, charX, charY - 40 - (50 - messageTip.timer)); messageTip.timer--;
            }
            ctx.fillStyle = "rgba(255,255,255,0.9)"; drawRoundedRect(ctx, 110, 15, 180, 45, 22.5);
            ctx.fillStyle = timeLeft < 10 ? "#FF85A1" : "#9BB7AD";
            ctx.font = "bold 18px Quicksand, Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(`å‰©ä½™æ—¶é—´: ${timeLeft}s`, 200, 40);
            
// --- 5. ç»˜åˆ¶èƒ¶å›Šæ»‘å—å¼€å…³ (è«å…°è¿ªé£æ ¼) ---
            ctx.save();
            const isBtn = (controlMode === 'button');
            // èƒŒæ™¯æ§½è‰²ï¼šæŒ‰é’®ç»¿/æ‘‡æ†ç²‰
            ctx.fillStyle = isBtn ? "rgba(155, 183, 173, 0.4)" : "rgba(217, 159, 169, 0.4)";
            drawRoundedRect(ctx, toggleUI.x, toggleUI.y, toggleUI.w, toggleUI.h, toggleUI.h/2);
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
            
            // ç»˜åˆ¶ç™½è‰²æ»‘å—
            const knobX = isBtn ? toggleUI.x + 15 : toggleUI.x + toggleUI.w - 15;
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(knobX, toggleUI.y + toggleUI.h/2, toggleUI.knobR, 0, Math.PI * 2);
            ctx.fill();
            
            // æ¨¡å¼æç¤ºå­—
            ctx.fillStyle = "#6B5E5E"; ctx.font = "bold 11px Arial"; ctx.textAlign = "center";
            ctx.fillText(isBtn ? "æŒ‰é”®æ¨¡å¼" : "æ‘‡æ†æ¨¡å¼", toggleUI.x + toggleUI.w/2, toggleUI.y + toggleUI.h + 12);
            ctx.restore();

            // --- 6. äº’æ–¥ç»˜åˆ¶ï¼šåªæ¸²æŸ“é€‰ä¸­çš„æ§åˆ¶å™¨ ---
            if (controlMode === 'button') {
                // ç»˜åˆ¶ä¸€æ’æŒ‰é’® (L, R, U, D)
                ctx.textBaseline = "alphabetic";
                for (let k in uiBtns) {
                    let btn = uiBtns[k]; ctx.save();
                    ctx.fillStyle = btn.active ? "rgba(217, 159, 169, 0.9)" : "rgba(255,255,255,0.7)";
                    ctx.strokeStyle = "white"; ctx.lineWidth = 4;
                    drawRoundedRect(ctx, btn.x, btn.y, btn.w, btn.h, 20); ctx.stroke();
                    if (btn.img.complete && btn.img.naturalWidth !== 0) {
                        const s = 28; if(btn.active) ctx.filter = 'brightness(0) invert(1)'; else ctx.globalAlpha = 0.6;
                        ctx.drawImage(btn.img, btn.x + (btn.w-s)/2, btn.y + (btn.h-s)/2, s, s);
                    }
                    ctx.restore();
                }
            } else {
                // ç»˜åˆ¶åŠé€æ˜æ‘‡æ†
                ctx.save();
                // åº•åº§
                ctx.beginPath(); ctx.arc(joystick.baseX, joystick.baseY, joystick.baseR, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(155, 183, 173, 0.35)"; ctx.fill();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.lineWidth = 4; ctx.stroke();
                // æ†å¤´
                ctx.beginPath(); ctx.arc(joystick.stickX, joystick.stickY, joystick.stickR, 0, Math.PI * 2);
                const g = ctx.createRadialGradient(joystick.stickX-5, joystick.stickY-5, 0, joystick.stickX, joystick.stickY, joystick.stickR);
                g.addColorStop(0, "rgba(217, 159, 169, 0.9)"); g.addColorStop(1, "rgba(217, 159, 169, 0.6)");
                ctx.fillStyle = g; ctx.fill();
                ctx.strokeStyle = "rgba(255, 255, 255, 0.8)"; ctx.stroke();
                ctx.restore();
            }

            drawUI() 
        }

        function drawExitPortal(ctx, x, y) {
            const pulse = Math.sin(Date.now() / 300) * 4;
            ctx.fillStyle = "rgba(155, 183, 173, 0.4)"; ctx.beginPath(); ctx.arc(x, y, 12 + pulse, 0, 7); ctx.fill();
            ctx.fillStyle = "#9BB7AD"; ctx.beginPath(); ctx.arc(x, y, 8, 0, 7); ctx.fill();
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = "white"; ctx.font = "bold 7px Arial"; ctx.textAlign = "center"; ctx.fillText("å‡ºå£", x, y + 2.5);
        }

        function drawUI() {
            
        }

        function endGame(win) {
            isGameOver = true; clearInterval(timerInterval);
            const title = document.getElementById('modal-title'), desc = document.getElementById('modal-desc');
            if (win) { CandyAudio.play('ding'); title.innerText = "æˆåŠŸè„±å‡ºï¼ğŸ­"; title.style.color = "#9BB7AD"; desc.innerText = `æ­å–œé€ƒç¦»è¿·é›¾ï¼å‰©ä½™æ—¶é—´: ${timeLeft}s`; }
            else { CandyAudio.play('sad'); title.innerText = "æ—¶é—´è€—å°½ ğŸ©"; title.style.color = "#D99FA9"; desc.innerText = "è¢«å›°åœ¨è¿·é›¾é‡Œäº†..."; }
            modal.style.display = 'flex';
        }

        function handleReset() { CandyAudio.play('click'); init(); }
        function drawRoundedRect(ctx, x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); ctx.fill(); }

        init();
    </script>
</body>
</html>