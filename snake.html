<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>SWEET_SNAKE // å½©è™¹ç³–æœè›‡</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* --- 1. æè‡´å±…ä¸­å¸ƒå±€ --- */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background-color: var(--bg-main); overflow: hidden;
            touch-action: manipulation;
        }

        #game-container {
            position: relative;
            display: flex; align-items: center; justify-content: center;
            width: 100%; height: 100%;
        }

        canvas {
            background: #F4F1F0;
            border: none !important;
            border-radius: 40px;
            box-shadow: none !important;
            max-width: 95vw;
            max-height: 92vh;
            width: auto; height: auto;
            display: block;
        }

        #hud, .controls { display: none !important; }
        .back-home { position: absolute; top: 20px; left: 20px; z-index: 1000; font-weight: bold; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(107, 94, 94, 0.2);
            display: none; align-items: center; justify-content: center;
            z-index: 2000; backdrop-filter: blur(10px);
        }
        .modal-content {
            background: white; width: 80%; max-width: 300px; padding: 30px;
            border-radius: 40px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="candy-bg"></div>
    <a href="index.html" class="back-home" id="back-link">ğŸ  è¿”å›</a>

    <div id="game-container">
        <!-- 400x800 ä¸€ä½“åŒ–æ¯”ä¾‹ -->
        <canvas id="gameCanvas" width="400" height="800"></canvas>
    </div>

    <div id="over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 style="color: var(--candy-pink); margin-bottom: 5px; font-size: 1.5rem;">å“å‘€ï¼æ’ç¿»å•¦ğŸ©</h2>
            <p style="color: #998888; font-size: 0.9rem; margin-bottom: 25px;">ä½ æ”¶é›†äº† <span id="final-score" style="color:var(--candy-pink); font-weight:bold;">0</span> ä¸ªç”œç‚¹</p>
            <button class="cute-btn wide" onclick="handleReset()" style="width: 100%; height: 50px; border-radius: 25px; font-size: 1rem;">å†æ¥ä¸€é¢—ç³–ï¼</button>
        </div>
    </div>

    <script>
        // --- 1. ç³–æœéŸ³æ•ˆå¼•æ“ (æ¸©æ¶¦Qå¼¹ç‰ˆ - å½»åº•å»å°–é”æ„Ÿ) ---
        const CandyAudio = {
            ctx: null,
            init() { 
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                if (this.ctx.state === 'suspended') this.ctx.resume(); 
            },
            play(type) {
                this.init();
                const n = this.ctx.currentTime;
                
                // æŒ‰é’®ç‚¹å‡»å·²æŒ‰è¦æ±‚é™éŸ³
                if (type === 'click') return; 

                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                const f = this.ctx.createBiquadFilter();

                // æ ¸å¿ƒï¼šå¼ºåŠ›ä½é€šæ»¤æ³¢ï¼Œåˆ‡æ‰æ‰€æœ‰åˆºè€³çš„é«˜é¢‘æ¯›åˆº
                f.type = 'lowpass';
                f.frequency.setValueAtTime(1200, n); // é™åˆ¶é¢‘ç‡åœ¨1200Hzä»¥ä¸‹ï¼Œå£°éŸ³å˜â€œè‚‰â€
                f.Q.value = 2; 

                o.connect(f);
                f.connect(g);
                g.connect(this.ctx.destination);

                if (type === 'ding') { 
                    // --- åƒåˆ°ç³–æœï¼šæ¸©æ¶¦çš„â€œå•µå˜¤â€å£° ---
                    o.type = 'sine'; // çº¯å‡€æ­£å¼¦æ³¢
                    // é¢‘ç‡ä»è¾ƒä½çš„ 300Hz æ»‘å‘ 900Hzï¼Œé¿å¼€é«˜é¢‘å°–åˆºåŒº
                    o.frequency.setValueAtTime(350, n);
                    o.frequency.exponentialRampToValueAtTime(900, n + 0.15);
                    
                    // æŸ”å’Œçš„éŸ³é‡åŒ…ç»œï¼šç¨å¾®åŠ é•¿èµ·éŸ³æ—¶é—´ï¼Œæ¶ˆé™¤â€œå’”å—’â€çˆ†ç ´éŸ³
                    g.gain.setValueAtTime(0, n);
                    g.gain.linearRampToValueAtTime(0.2, n + 0.02); 
                    g.gain.exponentialRampToValueAtTime(0.01, n + 0.4);
                    
                    o.start(n);
                    o.stop(n + 0.4);
                } 
                else if (type === 'sad') { 
                    // --- æ’å¢™ï¼šé—·å£°é—·æ°”çš„â€œå‘œå™—â€ ---
                    o.type = 'sine';
                    f.frequency.setValueAtTime(400, n); // æä½æ»¤æ³¢
                    
                    o.frequency.setValueAtTime(200, n);
                    o.frequency.linearRampToValueAtTime(60, n + 0.5);
                    
                    g.gain.setValueAtTime(0.15, n);
                    g.gain.linearRampToValueAtTime(0, n + 0.5);
                    
                    o.start(n);
                    o.stop(n + 0.5);
                }
            }
        };
        const iconAssets = {
            left: new Image(), right: new Image(), up: new Image(), down: new Image()
        };
        iconAssets.left.src = 'icons/left.svg'; iconAssets.right.src = 'icons/right.svg';
        iconAssets.up.src = 'icons/up.svg'; iconAssets.down.src = 'icons/down.svg';

        // --- 2. æ ¸å¿ƒé€»è¾‘ä¸UIå®šä¹‰ (å¤§æ ¼å­ç‰ˆæœ¬) ---
        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const modal = document.getElementById('over-modal');

        // --- æ ¸å¿ƒé…ç½®ï¼šé’ˆå¯¹ 28px çš„ç²¾å‡†å¯¹é½ ---
        const GRID_SIZE = 28; 
        const COLS = 13;      // 13 * 28 = 364px
        const ROWS = 18;      // 18 * 28 = 504px
        const GAME_X_OFFSET = (400 - COLS * GRID_SIZE) / 2; // ç»“æœä¸º 18px
        const GAME_Y_OFFSET = 90; // é€‚å½“ä¸‹ç§»ï¼Œç»™é¡¶éƒ¨ç•™ä½

        let snake, dir, food, score, isGameOver, lastTick = 0, rippleDecors = [];
        const SWEETS = ['ğŸ®', 'ğŸ¯', 'ğŸª', 'ğŸ§', 'ğŸ¦', 'ğŸ©', 'ğŸ§', 'ğŸ­'];
        
        // è›‡èº«å¤šå½©é…è‰²åº“
        const RAINBOW_COLORS = ['#A1B5D0', '#9BB7AD', '#E6D5B8', '#B4A7AF', '#C9A7AC'];

        const uiBtns = {
            L: { x: 100,  y: 680, w: 60, h: 50, img: iconAssets.left,  key: {x: -1, y: 0}, color: '#9BB7AD' },
            R: { x: 245, y: 680, w: 60, h: 50, img: iconAssets.right, key: {x: 1, y: 0},  color: '#9BB7AD' },
            U: { x: 170, y: 620, w: 60, h: 50, img: iconAssets.up,    key: {x: 0, y: -1}, color: '#D99FA9' },
            D: { x: 170, y: 680, w: 60, h: 50, img: iconAssets.down,  key: {x: 0, y: 1},  color: '#9BB7AD' }
        };

        // --- æ–°å¢ï¼šæ‘‡æ†çŠ¶æ€ç®¡ç† ---
const joystick = {
    baseX: 200,    // æ‘‡æ†ä¸­å¿ƒ X
    baseY: 680,    // æ‘‡æ†ä¸­å¿ƒ Y
    baseR: 50,     // æ‘‡æ†åº•åº§åŠå¾„
    stickX: 200,   // æ“çºµæ†å½“å‰ X
    stickY: 680,   // æ“çºµæ†å½“å‰ Y
    stickR: 25,    // æ“çºµæ†çƒä½“åŠå¾„
    active: false, // æ˜¯å¦æ­£åœ¨æ‹–æ‹½
    maxLen: 40     // æœ€å¤§æ‹‰åŠ¨è·ç¦»
};

// --- 1. æ–°å¢ï¼šæ§åˆ¶æ¨¡å¼æ€»å¼€å…³ ---
let controlMode = 'button'; // é»˜è®¤ä¸ºæŒ‰é’®æ¨¡å¼ï¼Œåˆ‡æ¢åå˜ä¸º 'joystick'

// å®šä¹‰å¼€å…³ç»„ä»¶åœ¨ç”»å¸ƒä¸Šçš„ä½ç½® (æ”¾åœ¨æ§åˆ¶åŒºå·¦ä¾§)
const toggleUI = {
    x: 25,          // è·ç¦»å·¦è¾¹
    y: 620,         // æ”¾åœ¨æ¸¸æˆåŒºä¸‹æ–¹ï¼ŒæŒ‰é”®åŒºä¸Šæ–¹
    w: 60,          // å®½åº¦
    h: 30,          // é«˜åº¦
    knobR: 12       // æ»‘å—åœ†ç‚¹åŠå¾„
};

        function init() {
            snake = [{x: 8, y: 12}, {x: 8, y: 13}, {x: 8, y: 14}];
            dir = {x: 0, y: -1}; score = 0; isGameOver = false;
            modal.style.display = 'none';
            spawnFood();
            requestAnimationFrame(loop);
        }

        

        function spawnFood() {
            const x = Math.floor(Math.random() * COLS);
            const y = Math.floor(Math.random() * ROWS);
            food = { x, y, type: SWEETS[Math.floor(Math.random() * SWEETS.length)] };
            if (snake.some(s => s.x === food.x && s.y === food.y)) spawnFood();
        }

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const t = e.touches ? e.touches[0] : e;
            return { x: (t.clientX - rect.left) * scaleX, y: (t.clientY - rect.top) * scaleY };
        }

        // --- ä¿®æ”¹ pointerdown ---
canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault(); CandyAudio.init();
    if (isGameOver) return;
    const pos = getTouchPos(e);

    // --- A. å¼€å…³ç‚¹å‡»åˆ¤å®š ---
    if (pos.x > toggleUI.x && pos.x < toggleUI.x + toggleUI.w &&
        pos.y > toggleUI.y && pos.y < toggleUI.y + toggleUI.h) {
        
        controlMode = (controlMode === 'button' ? 'joystick' : 'button');
        CandyAudio.play('click');
        draw(); 
        return; // ç‚¹å‡»å¼€å…³åç›´æ¥è¿”å›ï¼Œä¸è§¦å‘è›‡ç§»åŠ¨
    }

    // --- B. äº’æ–¥é€»è¾‘ï¼šæ ¹æ®æ¨¡å¼å†³å®šå“åº”å“ªç§æ“ä½œ ---
    if (controlMode === 'button') {
        // --- åªæœ‰åœ¨æŒ‰é’®æ¨¡å¼ä¸‹ï¼Œæ‰è¿è¡ŒåŸæœ¬çš„æŒ‰é’®ç‚¹å‡»æ£€æµ‹ ---
        for (let k in uiBtns) {
            let btn = uiBtns[k];
            if (pos.x > btn.x && pos.x < btn.x + btn.w && pos.y > btn.y && pos.y < btn.y + btn.h) {
                btn.active = true;
                if (!(btn.key.x === -dir.x && btn.key.y === -dir.y)) {
                    dir = btn.key; CandyAudio.play('click');
                }
            }
        }
    } else {
        // --- åªæœ‰åœ¨æ‘‡æ†æ¨¡å¼ä¸‹ï¼Œæ‰è¿è¡ŒåŸæœ¬çš„æ‘‡æ†æ¿€æ´»é€»è¾‘ ---
        const d = Math.hypot(pos.x - joystick.baseX, pos.y - joystick.baseY);
        if (d < joystick.baseR + 20) {
            joystick.active = true;
            handleMove(e.clientX || (e.touches && e.touches[0].clientX), e.clientY || (e.touches && e.touches[0].clientY));
        }
    }
    draw();
});

// --- æ–°å¢ï¼šå…¨å±€ pointermove ç›‘å¬ ---
window.addEventListener('pointermove', (e) => {
    if (!joystick.active || isGameOver) return;
    const pos = getTouchPos(e);
    updateJoystick(pos.x, pos.y);
    draw();
});

// --- ä¿®æ”¹ pointerup ---
window.addEventListener('pointerup', () => { 
    for (let k in uiBtns) uiBtns[k].active = false; 
    // æŠ¬èµ·æ—¶é‡ç½®æ‘‡æ†ä½ç½®
    joystick.active = false;
    joystick.stickX = joystick.baseX;
    joystick.stickY = joystick.baseY;
    draw(); 
});

// --- æ–°å¢ï¼šæ‘‡æ†é€»è¾‘è®¡ç®—å‡½æ•° ---
function updateJoystick(targetX, targetY) {
    const dx = targetX - joystick.baseX;
    const dy = targetY - joystick.baseY;
    const dist = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx);
    
    // é™åˆ¶æ‘‡æ†çƒä¸è¶…å‡ºèŒƒå›´
    const moveDist = Math.min(dist, joystick.maxLen);
    joystick.stickX = joystick.baseX + Math.cos(angle) * moveDist;
    joystick.stickY = joystick.baseY + Math.sin(angle) * moveDist;

    // å°†æ‘‡æ†ä½ç§»è½¬åŒ–ä¸ºè›‡çš„æ–¹å‘
    if (dist > 15) { // è®¾å®šæ­»åŒºï¼Œé˜²æ­¢è¯¯è§¦
        let newDir = { x: 0, y: 0 };
        if (Math.abs(dx) > Math.abs(dy)) {
            newDir = { x: dx > 0 ? 1 : -1, y: 0 };
        } else {
            newDir = { x: 0, y: dy > 0 ? 1 : -1 };
        }
        // é˜²æ­¢180åº¦æ‰å¤´
        if (!(newDir.x === -dir.x && newDir.y === -dir.y)) {
            if (dir.x !== newDir.x || dir.y !== newDir.y) {
                dir = newDir;
                CandyAudio.play('click');
            }
        }
    }
}

        function loop(t) {
            if (isGameOver) return;
            requestAnimationFrame(loop);
            if (t - lastTick < 200) return; // ç§»åŠ¨é€Ÿåº¦ç¨å¾®å‡æ…¢ä¸€ç‚¹ï¼Œæ‰‹æ„Ÿæ›´æ‰å®
            lastTick = t;

            const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
            if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS || snake.some(s => s.x === head.x && s.y === head.y)) {
                isGameOver = true; CandyAudio.play('sad');
                document.getElementById('final-score').innerText = score;
                modal.style.display = 'flex'; return;
            }

            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score++; CandyAudio.play('ding'); spawnFood();
            } else {
                snake.pop();
            }
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. HUD
            ctx.fillStyle = "rgba(255,255,255,0.9)";
            drawRoundedRect(ctx, 110, 20, 180, 45, 22.5);
            ctx.fillStyle = "#D99FA9";
            ctx.font = "bold 18px Quicksand, Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(`SWEETS: ${score}`, 200, 43);

            // 2. æ¸¸æˆåŒºåŸŸ
            // --- 3. æ¸¸æˆåŒºåŸŸæ‰˜ç›˜ä¸å±é™©è¾¹ç•Œ (13x20 ç½‘æ ¼) ---
            const gridWidth = COLS * GRID_SIZE;
            const gridHeight = ROWS * GRID_SIZE;
            const trayPadding = 12;

            // A. åº•å±‚ç™½è‰²å¥¶æ²¹æ‰˜ç›˜
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)"; 
            drawRoundedRect(ctx, 
                GAME_X_OFFSET - trayPadding, 
                GAME_Y_OFFSET - trayPadding, 
                gridWidth + (trayPadding * 2), 
                gridHeight + (trayPadding * 2), 
                35 // æ‰˜ç›˜å¤§åœ†è§’
            );

            // B. æ ¸å¿ƒï¼šæ­»äº¡è¾¹ç•Œçº¿ (åŠ ç²—çš„è«å…°è¿ªç²‰)
            ctx.strokeStyle = "rgba(217, 159, 169, 0.5)"; // è«å…°è¿ªç²‰é€æ˜ç‰ˆ
            ctx.lineWidth = 4; // è¾ƒç²—çš„çº¿æ¡ï¼Œæé†’è¿™æ˜¯å¢™å£
            ctx.lineJoin = "round";
            ctx.beginPath();
            // ç»˜åˆ¶ç´§è´´ç½‘æ ¼è¾¹ç¼˜çš„è¾¹æ¡†
            ctx.strokeRect(GAME_X_OFFSET, GAME_Y_OFFSET, gridWidth, gridHeight);

            // C. è¾…åŠ©ç½‘æ ¼çº¿ (å†…éƒ¨è™šçº¿æˆ–ç»†çº¿)
            ctx.strokeStyle = "rgba(107, 94, 94, 0.05)"; 
            ctx.lineWidth = 1;
            // ç«–çº¿
            for(let i = 1; i < COLS; i++) { 
                ctx.beginPath(); 
                ctx.moveTo(GAME_X_OFFSET + i * GRID_SIZE, GAME_Y_OFFSET); 
                ctx.lineTo(GAME_X_OFFSET + i * GRID_SIZE, GAME_Y_OFFSET + gridHeight); 
                ctx.stroke(); 
            }
            // æ¨ªçº¿
            for(let j = 1; j < ROWS; j++) {
                ctx.beginPath();
                ctx.moveTo(GAME_X_OFFSET, GAME_Y_OFFSET + j * GRID_SIZE);
                ctx.lineTo(GAME_X_OFFSET + gridWidth, GAME_Y_OFFSET + j * GRID_SIZE);
                ctx.stroke();
            }

            // D. æ ¸å¿ƒè¡¥å…¨ï¼šç½‘æ ¼è¿æ¥å¤„çš„ç²¾è‡´åœ†ç‚¹ (æ‰€æœ‰äº¤å‰ç‚¹)
            ctx.fillStyle = "rgba(107, 94, 94, 0.1)";
            for(let i = 0; i <= COLS; i++) {
                for(let j = 0; j <= ROWS; j++) {
                    ctx.beginPath();
                    // åœ¨æ¯ä¸€ä¸ªæ¨ªç«–çº¿äº¤å‰åæ ‡ç‚¹ç”»ä¸€ä¸ªå°åœ†ç‚¹
                    ctx.arc(GAME_X_OFFSET + i * GRID_SIZE, GAME_Y_OFFSET + j * GRID_SIZE, 1.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // E. è£…é¥°ï¼šå››ä¸ªè§’å¼ºåŒ– (ç±»ä¼¼å–æ™¯æ¡†ï¼Œæ›´æœ‰è®¾è®¡æ„Ÿ)
            ctx.strokeStyle = "#D99FA9";
            ctx.lineWidth = 3;
            const cornerSize = 15;
            // å·¦ä¸Šè§’
            ctx.beginPath(); ctx.moveTo(GAME_X_OFFSET, GAME_Y_OFFSET + cornerSize); ctx.lineTo(GAME_X_OFFSET, GAME_Y_OFFSET); ctx.lineTo(GAME_X_OFFSET + cornerSize, GAME_Y_OFFSET); ctx.stroke();
            // å³ä¸Šè§’
            ctx.beginPath(); ctx.moveTo(GAME_X_OFFSET + gridWidth - cornerSize, GAME_Y_OFFSET); ctx.lineTo(GAME_X_OFFSET + gridWidth, GAME_Y_OFFSET); ctx.lineTo(GAME_X_OFFSET + gridWidth, GAME_Y_OFFSET + cornerSize); ctx.stroke();
            // å·¦ä¸‹è§’
            ctx.beginPath(); ctx.moveTo(GAME_X_OFFSET, GAME_Y_OFFSET + gridHeight - cornerSize); ctx.lineTo(GAME_X_OFFSET, GAME_Y_OFFSET + gridHeight); ctx.lineTo(GAME_X_OFFSET + cornerSize, GAME_Y_OFFSET + gridHeight); ctx.stroke();
            // å³ä¸‹è§’
            ctx.beginPath(); ctx.moveTo(GAME_X_OFFSET + gridWidth - cornerSize, GAME_Y_OFFSET + gridHeight); ctx.lineTo(GAME_X_OFFSET + gridWidth, GAME_Y_OFFSET + gridHeight); ctx.lineTo(GAME_X_OFFSET + gridWidth, GAME_Y_OFFSET + gridHeight - cornerSize); ctx.stroke();

            // --- 3. ç»˜åˆ¶æè‡´Qå¼¹ï¼šSå‹æ³¢æµªå‘¼å¸è›‡èº« ---
            const time = Date.now() / 250; // åŠ¨ç”»é€Ÿåº¦å› å­

            // å€’åºç»˜åˆ¶ï¼šè®©è›‡å¤´æœ€åå åœ¨æœ€ä¸Šé¢ï¼Œæ›´æœ‰å±‚æ¬¡æ„Ÿ
            for (let i = snake.length - 1; i >= 0; i--) {
                const s = snake[i];
                
                // 1. åŸºç¡€ä¸­å¿ƒåæ ‡
                // --- ä¿®å¤æ ¸å¿ƒï¼šbaseX å¿…é¡»åŠ ä¸Š GAME_X_OFFSET ---
                const baseX = GAME_X_OFFSET + s.x * GRID_SIZE + GRID_SIZE / 2;
                const baseY = s.y * GRID_SIZE + GAME_Y_OFFSET + GRID_SIZE / 2;

                // 2. Så‹æ‰­åŠ¨é€»è¾‘ï¼šåªåœ¨å‚ç›´äºè¡Œè¿›æ–¹å‘çš„è½´ä¸Šåšæ³¢æµªä½ç§»
                // æ¯ä¸€ä¸ªèŠ‚æ®µ i éƒ½æœ‰ç›¸ä½å·®ï¼Œå½¢æˆé¡ºæ»‘çš„æ›²çº¿
                const wiggleMagnitude = GRID_SIZE * 0.15; // æ‰­åŠ¨å¹…åº¦
                const wiggleWave = Math.sin(time * 1.2 - i * 0.8);
                
                let offsetX = (dir.y !== 0) ? wiggleWave * wiggleMagnitude : 0;
                let offsetY = (dir.x !== 0) ? wiggleWave * wiggleMagnitude : 0;

                // 3. å‘¼å¸æ„Ÿé€»è¾‘ï¼šæ¯ä¸€é¢—çƒç‹¬ç«‹ç¼©æ”¾ï¼Œå¸¦æœ‰ç›¸ä½å·®
                const breathe = 1 + Math.sin(time * 2 - i * 0.4) * 0.08;
                
                // 4. å°¾éƒ¨å¾®ç¼©ï¼šè®©å°¾å·´çœ‹èµ·æ¥æ›´çµåŠ¨
                const tailScale = Math.max(0.6, 1 - (i / snake.length) * 0.3);
                
                // 5. æœ€ç»ˆçƒä½“åŠå¾„ï¼šç•¥å¤§äº GRID_SIZE çš„ä¸€åŠï¼Œç¡®ä¿è¿è´¯ä¸ç•™ç¼éš™
                const finalRadius = (GRID_SIZE * 0.65) * breathe * tailScale;

                ctx.save();
                ctx.translate(baseX + offsetX, baseY + offsetY);

                if (i === 0) {
                    // --- ç»˜åˆ¶è¶…çº§çµåŠ¨çš„å¤§å¤´å…”å…”è›‡å¤´ ---
                    ctx.fillStyle = '#D99FA9';
                    ctx.beginPath();
                    ctx.arc(0, 0, finalRadius * 1.1, 0, Math.PI * 2);
                    ctx.fill();

                    // ç»˜åˆ¶çµåŠ¨å¤§çœ¼
                    const eyeX = finalRadius * 0.45;
                    const eyeY = -finalRadius * 0.2;
                    
                    // çœ¼ç™½
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(-eyeX, eyeY, finalRadius * 0.4, 0, 7);
                    ctx.arc(eyeX, eyeY, finalRadius * 0.4, 0, 7);
                    ctx.fill();

                    // ç³å­” (å¸¦çœ¨çœ¼æ•ˆæœ)
                    const isBlinking = Math.sin(time * 0.5) > 0.98;
                    ctx.fillStyle = "#6B5E5E";
                    if (!isBlinking) {
                        ctx.beginPath();
                        ctx.arc(-eyeX, eyeY, finalRadius * 0.18, 0, 7);
                        ctx.arc(eyeX, eyeY, finalRadius * 0.18, 0, 7);
                        ctx.fill();
                    }

                    // è…®çº¢
                    ctx.fillStyle = "rgba(255, 133, 161, 0.4)";
                    ctx.beginPath();
                    ctx.arc(-eyeX * 1.3, eyeY + finalRadius * 0.6, finalRadius * 0.3, 0, 7);
                    ctx.arc(eyeX * 1.3, eyeY + finalRadius * 0.6, finalRadius * 0.3, 0, 7);
                    ctx.fill();

                } else {
                    // --- ç»˜åˆ¶å¤šå½©æœå†»èº«ä½“ (æ¯ä¸€é¢—éƒ½æ˜¯ç‹¬ç«‹çš„çƒ) ---
                    ctx.fillStyle = RAINBOW_COLORS[i % RAINBOW_COLORS.length];
                    ctx.beginPath();
                    ctx.arc(0, 0, finalRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // æ¯ä¸€é¢—çƒéƒ½æœ‰ç‹¬ç«‹çš„é«˜å…‰
                    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.beginPath();
                    ctx.ellipse(-finalRadius*0.3, -finalRadius*0.3, finalRadius*0.4, finalRadius*0.2, Math.PI/4, 0, 7);
                    ctx.fill();
                }

                // ç»Ÿä¸€çš„ç™½è‰²å¥¶æ²¹è¾¹ç¼˜æè¾¹
                ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // 4. é£Ÿç‰©
            ctx.font = "28px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(food.type, GAME_X_OFFSET + food.x*GRID_SIZE + GRID_SIZE/2, food.y*GRID_SIZE + GAME_Y_OFFSET + GRID_SIZE/2);

            

            // --- 5. ç»˜åˆ¶ç³–æœæ¨¡å¼å¼€å…³ (ä¸€äº®ä¸€ç­çš„è§†è§‰æ ¸å¿ƒ) ---
    ctx.save();
    // ç»˜åˆ¶å¼€å…³èƒŒæ™¯æ§½ (è«å…°è¿ªç»¿/ç²‰åˆ‡æ¢)
    ctx.fillStyle = controlMode === 'button' ? "rgba(155, 183, 173, 0.4)" : "rgba(217, 159, 169, 0.4)";
    drawRoundedRect(ctx, toggleUI.x, toggleUI.y, toggleUI.w, toggleUI.h, toggleUI.h/2);
    ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
    
    // ç»˜åˆ¶æ»‘å— (å·¦/å³æ»‘åŠ¨æ•ˆæœ)
    const knobX = controlMode === 'button' ? toggleUI.x + 15 : toggleUI.x + toggleUI.w - 15;
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(knobX, toggleUI.y + toggleUI.h/2, toggleUI.knobR, 0, Math.PI * 2);
    ctx.fill();
    
    // æ¨¡å¼æ–‡å­—è¯´æ˜ (å°å·§ç²¾è‡´)
    ctx.fillStyle = "#6B5E5E"; ctx.font = "bold 12px Arial"; ctx.textAlign = "center";
    ctx.fillText(controlMode === 'button' ? "æŒ‰é”®æ¨¡å¼" : "æ‘‡æ†æ¨¡å¼", toggleUI.x + toggleUI.w/2, toggleUI.y + toggleUI.h + 15);
    ctx.restore();

    // --- 6. æ ¸å¿ƒäº’æ–¥æ˜¾ç¤ºï¼šåªæ¸²æŸ“é€‰ä¸­çš„æ§åˆ¶å™¨ ---
    if (controlMode === 'button') {
        // ã€ç»˜åˆ¶æŒ‰é’®çš„ä»£ç å—ã€‘
        ctx.textBaseline = "alphabetic";
        for (let k in uiBtns) {
            let btn = uiBtns[k];
            // ... (ä½ åŸæ¥çš„ç»˜åˆ¶æŒ‰é’®çš„ä»£ç ï¼šctx.save() åˆ° ctx.restore()) ...


            // 5. åº•éƒ¨æŒ‰é’®
            ctx.textBaseline = "alphabetic";
            for (let b in uiBtns) {
                let btn = uiBtns[b];
                ctx.save();
                ctx.fillStyle = btn.active ? "rgba(217, 159, 169, 0.9)" : "rgba(255,255,255,0.7)";
                ctx.strokeStyle = "white"; ctx.lineWidth = 4;
                drawRoundedRect(ctx, btn.x, btn.y, btn.w, btn.h, 20);
                ctx.stroke();

                if (btn.img.complete && btn.img.naturalWidth !== 0) {
                    const iconSize = 28;
                    if(btn.active) ctx.filter = 'brightness(0) invert(1)';
                    else ctx.globalAlpha = 0.6;
                    ctx.drawImage(btn.img, btn.x + (btn.w - iconSize) / 2, btn.y + (btn.h - iconSize) / 2, iconSize, iconSize);
                }
                ctx.restore();
            }
        }
    } 
    else if (controlMode === 'joystick') {
        // ã€ç»˜åˆ¶æ‘‡æ†çš„ä»£ç å—ã€‘
        // ... (ä½ åŸæ¥çš„ç»˜åˆ¶æ‘‡æ†åº•åº§å’Œçƒçš„ä»£ç ï¼šctx.save() åˆ° ctx.restore()) ...

        // ç»˜åˆ¶æ‘‡æ†åº•åº§ (è–„è·ç»¿åŠé€æ˜)
        ctx.save();
        ctx.setLineDash([]); // ç¡®ä¿ä¸å—èƒŒæ™¯è™šçº¿å½±å“
        ctx.beginPath();
        ctx.arc(joystick.baseX, joystick.baseY, joystick.baseR, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(155, 183, 173, 0.3)"; // è«å…°è¿ªç»¿é€æ˜
        ctx.fill();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 3;
        ctx.stroke();

        // ç»˜åˆ¶æ‘‡æ†å¤´ (ç°ç²‰è‰²åŠé€æ˜)
        ctx.beginPath();
        ctx.arc(joystick.stickX, joystick.stickY, joystick.stickR, 0, Math.PI * 2);
        const stickGrad = ctx.createRadialGradient(
            joystick.stickX - 5, joystick.stickY - 5, 0,
            joystick.stickX, joystick.stickY, joystick.stickR
        );
        stickGrad.addColorStop(0, "rgba(217, 159, 169, 0.9)"); // äº®è‰²
        stickGrad.addColorStop(1, "rgba(217, 159, 169, 0.6)"); // è¾¹æ¡†æ·±è‰²
        ctx.fillStyle = stickGrad;
        ctx.fill();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
        ctx.stroke();
        ctx.restore();
    }

            // --- åœ¨ draw() å‡½æ•°æœ«å°¾ï¼Œç»˜åˆ¶å®ŒæŒ‰é’®åæ·»åŠ  ---
        
        

        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); ctx.fill();
        }

        function handleReset() { CandyAudio.play('click'); setTimeout(init, 100); }
        init();
    </script>
</body>
</html>